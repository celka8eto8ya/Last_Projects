[
  {
    "Id": "1436340",
    "ThreadId": "642065",
    "Html": "Hello All,<br />\n<br />\nI've got working code that receives samples and outputs the audio to speakers but re-sampling is very slow. Do you have suggestions that could immensely speed up the processing? Right now there are gaps in my audio which cause crackling because of the slowness. Most of the code is below for reference.<br />\n<pre><code>using (WasapiOut wasapiOut = new WasapiOut(audioClientShareMode_output, 700))\n                                {\n                                    try\n                                    {\n                                        wasapiOut.Init(bufferedWaveProvider);\n                                        wasapiOut.Volume = 1f;\n                                        wasapiOut.Play();\n\n                                        while (true)\n                                        {\n                                            byte[] arrayByte = m_queue.Dequeue();\n                                            if (null == arrayByte) { break; }\n\n                                            bufferedWaveProvider.AddSamples(arrayByte, 0, arrayByte.Length);\n                                        }\n                                    }\n                                    catch (Exception x) { }\n                                    wasapiOut.Stop();\n                                }</code></pre>\n\n<pre><code>/// &lt;summary&gt;\n        /// http://mark-dot-net.blogspot.com/2014/05/how-to-resample-audio-with-naudio.html\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;waveFormat_input&quot;&gt;&lt;/param&gt;\n        /// &lt;param name=&quot;waveFormat_output&quot;&gt;&lt;/param&gt;\n        /// &lt;param name=&quot;arrayByte_input&quot;&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        private byte[] Resample(EnumResamplerType enumResamplerType, WaveFormat waveFormat_input, WaveFormat waveFormat_output, byte[] arrayByte_input)\n        {\n            List&lt;byte[]&gt; listArrayByte_output = new List&lt;byte[]&gt;();\n            int totalBytesRead = 0, bytesRead = -1;\n\n            using (MemoryStream memoryStream_input = new MemoryStream(arrayByte_input))\n            {\n                using (RawSourceWaveStream rawSourceWaveStream_input =\n                    new RawSourceWaveStream(memoryStream_input, waveFormat_input))\n                {\n                    byte[] arrayByte_sub = null;\n                    if (EnumResamplerType.ACM.Equals(enumResamplerType)) // Limited to 16bit sample rate\n                    {\n                        using (WaveFormatConversionStream waveFormatConversionStream_output =\n                          new WaveFormatConversionStream(waveFormat_output, rawSourceWaveStream_input))\n                        {\n                            byte[] arrayByte = new byte[waveFormatConversionStream_output.WaveFormat.AverageBytesPerSecond];\n                            while (0 &lt; (bytesRead = waveFormatConversionStream_output.Read(\n                                arrayByte, 0, arrayByte.Length)))\n                            {\n                                arrayByte_sub = ArraySub(arrayByte, 0, bytesRead);\n                                //Filter(waveFormat_output, ref arrayByte_sub);\n                                listArrayByte_output.Add(arrayByte_sub);\n                                totalBytesRead += bytesRead;\n                            }\n                        }\n                    }\n                    else if (EnumResamplerType.MediaFoundation.Equals(enumResamplerType))\n                    {\n                        using (MediaFoundationResampler mediaFoundationResampler = new MediaFoundationResampler(rawSourceWaveStream_input, waveFormat_output))\n                        {\n                            mediaFoundationResampler.ResamplerQuality = 60;\n\n                            byte[] arrayByte = new byte[waveFormat_output.AverageBytesPerSecond];\n                            while (0 &lt; (bytesRead = mediaFoundationResampler.Read(\n                                arrayByte, 0, arrayByte.Length)))\n                            {\n                                arrayByte_sub = ArraySub(arrayByte, 0, bytesRead);\n                                //Filter(waveFormat_output, ref arrayByte_sub);\n                                listArrayByte_output.Add(arrayByte_sub);\n                                totalBytesRead += bytesRead;\n                            }\n                        }\n                    }\n                    else if (EnumResamplerType.WDL.Equals(enumResamplerType))\n                    {\n                        WdlResamplingSampleProvider wdlResamplingSampleProvider = new WdlResamplingSampleProvider(rawSourceWaveStream_input.ToSampleProvider(), waveFormat_output.SampleRate);\n\n                        float[] arrayFloat = new float[waveFormat_output.AverageBytesPerSecond / 4];\n                        while (0 &lt; (bytesRead = wdlResamplingSampleProvider.Read(\n                            arrayFloat, 0, arrayFloat.Length)))\n                        {\n                            arrayByte_sub = ArrayFloatToByte(ArraySub(arrayFloat, 0, bytesRead));\n                            //Filter(waveFormat_output, ref arrayByte_sub);\n                            listArrayByte_output.Add(arrayByte_sub);\n                            totalBytesRead += bytesRead;\n                        }\n                    }\n                }\n            }\n\n            byte[] arrayByte_output = new byte[totalBytesRead];\n            for (int i = 0; i &lt; listArrayByte_output.Count; i++)\n            {\n                Buffer.BlockCopy(listArrayByte_output[i], 0, arrayByte_output, bytesRead, listArrayByte_output[i].Length);\n                bytesRead += listArrayByte_output[i].Length;\n            }\n\n            return arrayByte_output;\n        }\n\n/// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        public enum EnumResamplerType\n        {\n            ACM,\n            MediaFoundation,\n            WDL\n        }\n\n/// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;arrayByte&quot;&gt;&lt;/param&gt;\n        public void Write(byte[] arrayByte)\n        {\n            if (m_play &amp;&amp; null != arrayByte &amp;&amp; null != m_waveFormat_input &amp;&amp; null != m_waveFormat_output)\n            {\n                byte[] arrayByte_resampled = Resample(m_enumResamplerType, m_waveFormat_input, m_waveFormat_output, arrayByte);\n                m_queue.Enqueue(arrayByte_resampled);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Attempt to prevent crackling\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;arrayByte&quot;&gt;&lt;/param&gt;\n        public void DelayedWrite(byte[] arrayByte)\n        {\n            if (m_play &amp;&amp; null != arrayByte &amp;&amp; null != m_waveFormat_input &amp;&amp; null != m_waveFormat_output)\n            {\n                byte[] arrayByte_resampled = Resample(m_enumResamplerType, m_waveFormat_input, m_waveFormat_output, arrayByte);\n                int offsetSource = 0, bytesToBeWritten;\n                while (offsetSource &lt; arrayByte_resampled.Length)\n                {\n                    bytesToBeWritten = Math.Min(arrayByte_resampled.Length - offsetSource, m_arrayByteDestination.Length - m_offsetDestination);\n                    Buffer.BlockCopy(arrayByte_resampled, offsetSource, m_arrayByteDestination, m_offsetDestination, bytesToBeWritten);\n                    offsetSource += bytesToBeWritten;\n                    m_offsetDestination += bytesToBeWritten;\n\n                    // Need To Flush?\n                    if (m_offsetDestination &gt;= m_arrayByteDestination.Length)\n                    {\n                        m_queue.Enqueue(m_arrayByteDestination);\n                        m_offsetDestination = 0;\n                    }\n                }\n            }\n        } private byte[] m_arrayByteDestination = new byte[1024 * 1500];\n        private int m_offsetDestination = 0;</code></pre>\n\n",
    "PostedDate": "2015-07-28T10:25:30.083-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1437199",
    "ThreadId": "642065",
    "Html": "<code>WasapiOut</code> already resamples for you (as does <code>WaveOutEvent</code>), so there is no need for all this code.<br />\n",
    "PostedDate": "2015-08-04T07:28:09.137-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1438141",
    "ThreadId": "642065",
    "Html": "Thank you for replying! It seems if I don't resample then nothing works. The line containing wasapiOut.Init(bufferedWaveProvider); throws the following exception if a waveformat of 16bit PCM, 8kHz, 1 channels is passed in. I've included all the code in a zipped dropbox link. Please let me know what I'm doing wrong. If you need any other information let me know. Do you have a paypal? I'll donate to get this to work.<br />\n<br />\nI'm coupling the Exacq API (Video Management Software) with the NAudio API. All of the byte arrays coming from the exacq API only use 1 channel with 16 bits (raw). The frequency has to be queried from each camera (raw).<br />\n<br />\n{System.NotSupportedException: Can't find a supported format to use<br />\n   at NAudio.Wave.WasapiOut.Init(IWaveProvider waveProvider) in c:\\GDIT\\Source Code\\C#\\Kinect Mirror Training\\Audio\\NAudio\\Wave\\WaveOutputs\\WasapiOut.cs:line 326<br />\n   at MiddleTier.Audio.AudioPlayer_PcmRaw.&lt;&gt;c__DisplayClass2.&lt;Start&gt;b__0() in c:\\GDIT\\Source Code\\C#\\Kinect Mirror Training\\MiddleTier.Audio\\AudioPlayer_PcmRaw.cs:line 165}<br />\n<br />\n<a href=\"https://www.dropbox.com/s/2khjqx9syg7t22g/ForMarkHeath.zip?dl=0\" rel=\"nofollow\">https://www.dropbox.com/s/2khjqx9syg7t22g/ForMarkHeath.zip?dl=0</a><br />\n",
    "PostedDate": "2015-08-11T07:28:19.717-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1443241",
    "ThreadId": "642065",
    "Html": "Any advice on on my last comment?<br />\n",
    "PostedDate": "2015-09-04T12:50:27.747-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1443489",
    "ThreadId": "642065",
    "Html": "Any reason why you need to use WASAPI out? WaveOutEvent will probably be easier if you are working at 16 bit 8kHz mono. Wasapi likes to run stereo, floating point, and 44.1kHz or 48kHz.<br />\n",
    "PostedDate": "2015-09-07T13:31:44.963-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]