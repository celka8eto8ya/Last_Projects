[
  {
    "Id": "596757",
    "ThreadId": "253767",
    "Html": "<p>I am using a slightly modified code block from PracticeSharp that applies effects to the wave provider.<br /> The CurrentTime property of the wave provider always seems to be 200ms + later than what I am hearing.<br /> The latency increases as I set the Direct Sound latency value higher.<br /> I can raise an event with the current play time, but I cannot trust the value I am getting from the Wave provider.<br /> Subscribing to the<span style=\"color: green;\"> PlayPositionChanged</span> event of the wave provider also gives me the \"later than I am hearing\" value.<br /> Anyone have a tip on how I can get the true time value of what I am hearing?<br /> I also noticed that the event only fires 10 times a second and I need it to fire every 33ms.<br /> What do i need to set so that smaller blocks of data are being processed and the event gets raised more frequently?<br /> I have tried</p>\n<div style=\"color: black; background-color: white;\">\n<pre>((bytesRead / format.Channels) / format.SampleRate) * 1000</pre>\nto get an offset in milliseconds, but I would think that the WaveProvider could do this since it has all of the information that I am using.</div>\n<p>Here is the code block:</p>\n<div style=\"color: black; background-color: white;\">\n<pre>  <span style=\"color: blue;\">Private</span> <span style=\"color: blue;\">Sub</span> ProcessAudio()\n    m_stopWorker = <span style=\"color: blue;\">False</span>\n    m_workerRunning = <span style=\"color: blue;\">True</span>\n\n    <span style=\"color: blue;\">Try</span>\n      <span style=\"color: blue;\">Dim</span> format <span style=\"color: blue;\">As</span> WaveFormat = m_waveChannel.WaveFormat\n      <span style=\"color: blue;\">Dim</span> bufferSecondLength <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = format.SampleRate * format.Channels\n      <span style=\"color: blue;\">Dim</span> inputBuffer <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Byte</span>() = <span style=\"color: blue;\">New</span> <span style=\"color: blue;\">Byte</span>(BufferSamples * 4 - 1) {}\n\n      <span style=\"color: blue;\">Dim</span> convertInputBuffer <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">New</span> ByteAndFloatsConverter()\n      convertInputBuffer.Bytes = inputBuffer\n\n      <span style=\"color: blue;\">Dim</span> outBufferSizeFloats <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">UInteger</span> = <span style=\"color: blue;\">CUInt</span>(convertInputBuffer.Bytes.Length) \\ <span style=\"color: blue;\">CUInt</span>(4 * format.Channels)\n\n      <span style=\"color: blue;\">Dim</span> bytesRead <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span>\n      <span style=\"color: blue;\">Dim</span> floatsRead <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span>\n      <span style=\"color: blue;\">Dim</span> samplesProcessed <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">UInteger</span> = 0\n      <span style=\"color: blue;\">Dim</span> bufferIndex <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = 0\n      <span style=\"color: blue;\">Dim</span> actualEndMarker <span style=\"color: blue;\">As</span> TimeSpan = TimeSpan.Zero\n\n      <span style=\"color: green;\">'AddHandler m_inputProvider.PlayPositionChanged, AddressOf inputProvider_PlayPositionChanged</span>\n\n      <span style=\"color: blue;\">While</span> <span style=\"color: blue;\">Not</span> m_stopWorker <span style=\"color: blue;\">AndAlso</span> m_waveChannel.Position &lt; m_waveChannel.Length\n        <span style=\"color: blue;\">SyncLock</span> PropertiesLock\n          m_waveChannel.Volume = m_volume\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">SyncLock</span>\n\n        <span style=\"color: green;\">'Read samples from file</span>\n\n        <span style=\"color: blue;\">Dim</span> myEffectStartTime <span style=\"color: blue;\">As</span> DateTime = Now\n\n        <span style=\"color: green;\">' Change current play position</span>\n        <span style=\"color: blue;\">SyncLock</span> CurrentPlayTimeLock\n          <span style=\"color: blue;\">If</span> m_newPlayTimeRequested <span style=\"color: blue;\">Then</span>\n            m_waveChannel.CurrentTime = m_newPlayTime\n            m_newPlayTimeRequested = <span style=\"color: blue;\">False</span>\n          <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">SyncLock</span>\n\n        <span style=\"color: green;\">' *** Read one chunk from input file ***</span>\n        bytesRead = m_waveChannel.Read(convertInputBuffer.Bytes, 0, convertInputBuffer.Bytes.Length)\n        <span style=\"color: green;\">' **************************************</span>\n\n        floatsRead = bytesRead \\ ((4) * format.Channels)\n        samplesProcessed = floatsRead\n\n        ApplyPitchShiftEffect(convertInputBuffer.Floats, floatsRead)\n\n        <span style=\"color: blue;\">Dim</span> currentBufferTime <span style=\"color: blue;\">As</span> TimeSpan = m_waveChannel.CurrentTime\n\n        m_inputProvider.AddSamples(convertInputBuffer.Bytes, 0, convertInputBuffer.Bytes.Length, currentBufferTime)\n\n        <span style=\"color: blue;\">While</span> <span style=\"color: blue;\">Not</span> m_stopWorker <span style=\"color: blue;\">AndAlso</span> m_inputProvider.GetQueueCount() &gt; BusyQueuedBuffersThreshold\n          Thread.Sleep(10)\n          <span style=\"color: blue;\">SyncLock</span> CurrentPlayTimeLock\n            m_currentPlayTime = m_waveChannel.CurrentTime\n          <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">SyncLock</span>\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">While</span>\n\n        m_effectLatency = Now.Subtract(myEffectStartTime)\n\n        <span style=\"color: blue;\">Dim</span> actualTime <span style=\"color: blue;\">As</span> TimeSpan = m_currentPlayTime.Subtract(m_effectLatency)\n\n        <span style=\"color: blue;\">RaiseEvent</span> PlayTimeChanged(<span style=\"color: blue;\">Me</span>, <span style=\"color: blue;\">New</span> BufferedPlayEventArgs(actualTime))\n\n      <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">While</span>\n\n      <span style=\"color: green;\">' Stop listening to PlayPositionChanged events</span>\n      <span style=\"color: green;\">'RemoveHandler m_inputProvider.PlayPositionChanged, AddressOf inputProvider_PlayPositionChanged</span>\n\n      <span style=\"color: green;\">' Fix to current play time not finishing up at end marker (Wave channel uses positions)</span>\n      <span style=\"color: blue;\">If</span> <span style=\"color: blue;\">Not</span> m_stopWorker <span style=\"color: blue;\">AndAlso</span> CurrentPlayTime &lt; actualEndMarker <span style=\"color: blue;\">Then</span>\n        <span style=\"color: blue;\">SyncLock</span> CurrentPlayTimeLock\n          m_currentPlayTime = actualEndMarker\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">SyncLock</span>\n      <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\n\n      <span style=\"color: green;\">'#End Region</span>\n      ChangeStatus(Statuses.Stopped)\n    <span style=\"color: blue;\">Finally</span>\n      m_workerRunning = <span style=\"color: blue;\">False</span>\n    <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Try</span>\n  <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Sub</span>\n</pre>\n</div>",
    "PostedDate": "2011-04-13T12:04:30.463-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "597450",
    "ThreadId": "253767",
    "Html": "<p>I'm not sure what is firing the PlayPositionChanged event - this must be a feature of Practice Sharp, and you should be able to configure it to fire as often as you need. It might be worth asking a question there. It is quite hard to get an accurate handle on exactly what is being played as audio software typically renders ahead of time and then passes buffers to the sound card. The smaller those buffers (i.e. lower latency), the more accurate a picture of current position you will get, but lower latency is more processor intensive</p>\r\n<p>Mark</p>",
    "PostedDate": "2011-04-14T13:11:24.48-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "597886",
    "ThreadId": "253767",
    "Html": "<p>Thanks for the reply, I'll dig deeper into seeing exactly what is going on in my code now that I am clear on the strategy.</p>\r\n<p>Do you have a small snippet available that demonstrates how you intended effects to be inserted from file load to play stopped?</p>\r\n<p>Is this the intended workflow?</p>\r\n<p>waveChannel.read ----&gt; ApplyEffect ---&gt; InputProvider.addSamples&nbsp;</p>\r\n<p>Would it be possible to make the WaveChannel or any other input/provider have an effect chain : List(of IEffect) and have the IEffect/IEffectChain interface be part of NAudio?</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-04-15T05:59:28.047-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "597904",
    "ThreadId": "253767",
    "Html": "<p>I implemented an effect chain as part of the Skype Voice Changer project, and my intention has always been to eventually move it into NAudio. It is quite easy to augment NAudio with your own custom one though.</p>\r\n<p>I would usually insert effects after going to floating point as it makes writing the DSP code much easier</p>\r\n<p>Mark</p>",
    "PostedDate": "2011-04-15T06:27:34.237-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]