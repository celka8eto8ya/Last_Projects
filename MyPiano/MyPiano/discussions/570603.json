[
  {
    "Id": "1316394",
    "ThreadId": "570603",
    "Html": "using System;\r<br />\nusing System.Collections.Generic;\r<br />\nusing System.Text;\r<br />\nusing NAudio.Wave;\r<br />\nusing System.Threading;\r<br />\nusing System.Diagnostics;\r<br />\nusing System.Runtime.InteropServices;\r<br />\nusing NAudio.CoreAudioApi;\r<br />\n<br />\n// for consistency this should be in NAudio.Wave namespace, but left as it is for backwards compatibility\r<br />\nnamespace NAudio.Wave\r<br />\n{<br />\n<pre><code>/// &lt;summary&gt;\n/// Audio Capture using Wasapi\n/// See http://msdn.microsoft.com/en-us/library/dd370800%28VS.85%29.aspx\n/// &lt;/summary&gt;\npublic class WaveDetect : WasapiLoopbackCapture\n{\n    public delegate void SoundPlayingHandler();\n    public event SoundPlayingHandler SoundPlaying;\n\n    public delegate void NoSoundPlayingHandler();\n    public event NoSoundPlayingHandler NoSoundPlaying;\n\n    public event EventHandler&lt;WaveInEventArgs&gt; DataAvailable;\n    private byte[] recordBuffer;\n    protected override void ReadNextPacket(AudioCaptureClient capture)\n    {\n        int packetSize = capture.GetNextPacketSize();\n        int recordBufferOffset = 0;\n        //Debug.WriteLine(string.Format(&quot;packet size: {0} samples&quot;, packetSize / 4));\n        if (packetSize ==0)\n        {\n            NoSoundPlaying();\n        }\n        while (packetSize != 0)\n        {\n            int framesAvailable;\n            AudioClientBufferFlags flags;\n            IntPtr buffer = capture.GetBuffer(out framesAvailable, out flags);\n\n            int bytesAvailable = framesAvailable * bytesPerFrame;\n\n            // apparently it is sometimes possible to read more frames than we were expecting?\n            // fix suggested by Michael Feld:\n            int spaceRemaining =11;//=  Math.Max(0, recordBuffer.Length - recordBufferOffset);\n            if (spaceRemaining &lt; bytesAvailable &amp;&amp; recordBufferOffset &gt; 0)\n            {\n                if (DataAvailable != null) DataAvailable(this, new WaveInEventArgs(recordBuffer, recordBufferOffset));\n                recordBufferOffset = 0;\n            }\n\n            // if not silence...\n            if ((flags &amp; AudioClientBufferFlags.Silent) != AudioClientBufferFlags.Silent)\n            {\n               SoundPlaying();\n              //  Marshal.Copy(buffer, recordBuffer, recordBufferOffset, bytesAvailable);\n            }\n            else\n            {\n            NoSoundPlaying();\n               // Array.Clear(recordBuffer, recordBufferOffset, bytesAvailable);\n            }\n            recordBufferOffset += bytesAvailable;\n            capture.ReleaseBuffer(framesAvailable);\n            packetSize = capture.GetNextPacketSize();\n        }\n        if (DataAvailable != null)\n        {\n            DataAvailable(this, new WaveInEventArgs(recordBuffer, recordBufferOffset));\n        }\n    }\n}</code></pre>\n\n}<br />\n",
    "PostedDate": "2014-10-24T17:30:27.273-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]