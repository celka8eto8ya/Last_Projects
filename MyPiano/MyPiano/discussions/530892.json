[
  {
    "Id": "1205858",
    "ThreadId": "530892",
    "Html": "Hi and thanks for a great piece of software :)\r<br />\n<br />\nI'm trying to use NAudio to trim wav files and then fade them in and out.\r<br />\nI have managed to trim and fade in with 0 problems, but when I try to use fade out rather than fading the end of the track, it fades from the beginning.\r<br />\nI have tried playing with different values for &quot;int sample = 0;&quot;, but have had no luck.\r<br />\n<br />\nCode I am using is from this forum from someone asking about fade out.<br />\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing NAudio;\nusing NAudio.Mixer;\nusing NAudio.Utils;\nusing NAudio.Wave;\n\nnamespace ALAMO\n{\n\n     \n\n\n    public class FadeInOutSampleProvider : ISampleProvider\n    {        \n        enum FadeState\n        {\n            Silence,\n            FadingIn,\n            FullVolume,\n            FadingOut,\n        }\n\n        private readonly object lockObject = new object();\n        private readonly ISampleProvider source;\n        private int fadeSamplePosition;\n        private int fadeSampleCount;\n        private FadeState fadeState;\n\n        public FadeInOutSampleProvider(ISampleProvider source)\n        {\n            this.source = source;\n            this.fadeState = FadeState.FullVolume;\n        }\n\n        public void BeginFadeIn(double fadeDurationInMilliseconds)\n        {\n            lock (lockObject)\n            {\n                fadeSamplePosition = 0;\n                fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);\n                fadeState = FadeState.FadingIn;\n            }\n        }\n\n        public void BeginFadeOut(double fadeDurationInMilliseconds)\n        {\n            lock (lockObject)\n            {\n                fadeSamplePosition = 0;\n                fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);\n                fadeState = FadeState.FadingOut;\n            }\n        }\n\n        public int Read(float[] buffer, int offset, int count)\n        {\n            int sourceSamplesRead = source.Read(buffer, offset, count);\n            lock (lockObject)\n            {\n                if (fadeState == FadeState.FadingIn)\n                {\n                    FadeIn(buffer, offset, sourceSamplesRead);\n                }\n                else if (fadeState == FadeState.FadingOut)\n                {\n                    FadeOut(buffer, offset, sourceSamplesRead);\n                }\n                else if (fadeState == FadeState.Silence)\n                {\n                    ClearBuffer(buffer, offset, count);\n                }\n            }\n            return sourceSamplesRead;\n        }\n\n        private static void ClearBuffer(float[] buffer, int offset, int count)\n        {\n            for (int n = 0; n &lt; count; n++)\n            {\n                buffer[n + offset] = 0;\n            }\n        }\n\n        private void FadeOut(float[] buffer, int offset, int sourceSamplesRead)\n        {\n            int sample = 0;\n            while (sample &lt; sourceSamplesRead)\n            {\n                float multiplier = 1.0f - (fadeSamplePosition / (float)fadeSampleCount);\n                for (int ch = 0; ch &lt; source.WaveFormat.Channels; ch++)\n                {\n                    buffer[offset + sample++] *= multiplier;\n                }\n                fadeSamplePosition++;\n                if (fadeSamplePosition &gt; fadeSampleCount)\n                {\n                    fadeState = FadeState.Silence;\n                    // clear out the end\n                    ClearBuffer(buffer, sample + offset, sourceSamplesRead - sample);\n                    break;\n                }\n            }\n        }\n\n        private void FadeIn(float[] buffer, int offset, int sourceSamplesRead)\n        {\n            int sample = 0;\n            while (sample &lt; sourceSamplesRead)\n            {\n                float multiplier = (fadeSamplePosition / (float)fadeSampleCount);\n                for (int ch = 0; ch &lt; source.WaveFormat.Channels; ch++)\n                {\n                    buffer[offset + sample++] *= multiplier;\n                }\n                fadeSamplePosition++;\n                if (fadeSamplePosition &gt; fadeSampleCount)\n                {\n                    fadeState = FadeState.FullVolume;\n                    // no need to multiply any more\n                    break;\n                }\n            }\n        }\n\n        public WaveFormat WaveFormat\n        {\n            get { return source.WaveFormat; }\n        }\n              \n           \n    }\n}\n</code></pre>\n\nAnd I am calling it from a button on a Windows Form App with the following code:<br />\n<pre><code>var afr = new AudioFileReader(filename);\n            var fader = new FadeInOutSampleProvider(afr);\n            fader.BeginFadeOut(5500);\n            var stwp = new NAudio.Wave.SampleProviders.SampleToWaveProvider(fader);\n            WaveFileWriter.CreateWaveFile(filename, stwp); </code></pre>\n\nI am imagining that I am making a basic mistake as only been teaching myself C# for a week now, but would really appreciate help on this problem.\r<br />\n<br />\nThanks in advance <br />\n",
    "PostedDate": "2014-02-09T11:06:48.217-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1206717",
    "ThreadId": "530892",
    "Html": "SampleProviders don't know when the end of the file will be, so BeginFadeOut means begin the fade-out immediately. I'd personally make a custom ISampleProvider that in its Read method began the fade out when it knew it was 5 seconds from the end of the file. \r<br />\n<br />\nHaving said that it would be a nice addition to FadeInOutSampleProvider to schedule a delayed fade out, I might see if I can do that for the next NAudio<br />\n",
    "PostedDate": "2014-02-11T02:10:20.26-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1206971",
    "ThreadId": "530892",
    "Html": "You are a superstar :)\r<br />\n<br />\nAs said I'm only a week into learning C#, so imagine that is going to cause me some puzzlement. lol\r<br />\nBut really appreciate the feedback as lets me know I'm not just making a ball-sack of things.\r<br />\nAs is Windows Restore wiped the project this related to, so going back to drawing board as is.\r<br />\nWould love it if a future release would recognise end of track as a basis for when to start fade-out.\r<br />\nTried using a command along lines of &quot;TrackSampleCount&quot;, that I assumed counted (in a way) length of track as a variable in working out when to start fade out. Think code in &quot; private void FadeOut &quot; was changed from &quot;int sample = 0&quot; to &quot;int sample = TrackSampleCount - BeginFadeOut&quot; but didn;t work. :(\r<br />\nAs referenced earlier, going to be starting from scratch with this project, so if I beat you to a solution I will post it here :)\r<br />\nThanks again :)<br />\n",
    "PostedDate": "2014-02-11T12:40:45.353-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1211544",
    "ThreadId": "530892",
    "Html": "I came up with a simple solution for this. Reverse Audio.\r<br />\nIf Fade start, reverse audio, fade start again, you get the same effect.\r<br />\n<br />\nFor anyone who is interested the code for my class file goes as following:<br />\n<pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing NAudio;\nusing NAudio.Mixer;\nusing NAudio.Utils;\nusing NAudio.Wave;\n\nnamespace ALAMO.Elements\n{\n\n\n\n\n    public class FadeInOutSampleProvider : ISampleProvider\n    {\n        enum FadeState\n        {\n            Silence,\n            FadingIn,\n            FullVolume,\n            FadingOut,\n        }\n\n        private readonly object lockObject = new object();\n        private readonly ISampleProvider source;\n        private int fadeSamplePosition;\n        private int fadeSampleCount;\n        private FadeState fadeState;\n\n        public FadeInOutSampleProvider(ISampleProvider source)\n        {\n            this.source = source;\n            this.fadeState = FadeState.FullVolume;\n        }\n\n        public void BeginFadeIn(double fadeDurationInMilliseconds)\n        {\n            lock (lockObject)\n            {\n                fadeSamplePosition = 0;\n                fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);\n                fadeState = FadeState.FadingIn;\n            }\n        }\n\n        public void BeginFadeOut(double fadeDurationInMilliseconds)\n        {\n            lock (lockObject)\n            {\n                fadeSamplePosition = 0;\n                fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);\n                fadeState = FadeState.FadingOut;\n            }\n        }\n\n        public int Read(float[] buffer, int offset, int count)\n        {\n            int sourceSamplesRead = source.Read(buffer, offset, count);\n            lock (lockObject)\n            {\n                if (fadeState == FadeState.FadingIn)\n                {\n                    FadeIn(buffer, offset, sourceSamplesRead);\n                }\n                else if (fadeState == FadeState.FadingOut)\n                {\n                    FadeOut(buffer, offset, sourceSamplesRead);\n                }\n                else if (fadeState == FadeState.Silence)\n                {\n                    ClearBuffer(buffer, offset, count);\n                }\n            }\n            return sourceSamplesRead;\n        }\n\n        private static void ClearBuffer(float[] buffer, int offset, int count)\n        {\n            for (int n = 0; n &lt; count; n++)\n            {\n                buffer[n + offset] = 0;\n            }\n        }\n\n        private void FadeOut(float[] buffer, int offset, int sourceSamplesRead)\n        {\n            int sample = 0;\n            while (sample &lt; sourceSamplesRead)\n            {\n                float multiplier = 1.0f - (fadeSamplePosition / (float)fadeSampleCount);\n                for (int ch = 0; ch &lt; source.WaveFormat.Channels; ch++)\n                {\n                    buffer[offset + sample++] *= multiplier;\n                }\n                fadeSamplePosition++;\n                if (fadeSamplePosition &gt; fadeSampleCount)\n                {\n                    fadeState = FadeState.Silence;\n                    // clear out the end\n                    ClearBuffer(buffer, sample + offset, sourceSamplesRead - sample);\n                    break;\n                }\n            }\n        }\n\n        private void FadeIn(float[] buffer, int offset, int sourceSamplesRead)\n        {\n            int sample = 0;\n            while (sample &lt; sourceSamplesRead)\n            {\n                float multiplier = (fadeSamplePosition / (float)fadeSampleCount);\n                for (int ch = 0; ch &lt; source.WaveFormat.Channels; ch++)\n                {\n                    buffer[offset + sample++] *= multiplier;\n                }\n                fadeSamplePosition++;\n                if (fadeSamplePosition &gt; fadeSampleCount)\n                {\n                    fadeState = FadeState.FullVolume;\n                    // no need to multiply any more\n                    break;\n                }\n            }\n        }\n\n        public WaveFormat WaveFormat\n        {\n            get { return source.WaveFormat; }\n        }\n    }\n\n\n        public static class Trim\n        {\n            public static void TrimWavFile(string inPath, string outPath, TimeSpan cutFromStart, TimeSpan cutFromEnd)\n            {\n                using (WaveFileReader reader = new WaveFileReader(inPath))\n                {\n                    using (WaveFileWriter writer = new WaveFileWriter(outPath, reader.WaveFormat))\n                    {\n                        int bytesPerMillisecond = reader.WaveFormat.AverageBytesPerSecond / 1000;\n\n                        int startPos = (int)cutFromStart.TotalMilliseconds * bytesPerMillisecond;\n                        startPos = startPos - startPos % reader.WaveFormat.BlockAlign;\n\n                        int endBytes = (int)cutFromEnd.TotalMilliseconds * bytesPerMillisecond;\n                        endBytes = endBytes - endBytes % reader.WaveFormat.BlockAlign;\n                        int endPos = (int)reader.Length - endBytes;\n\n                        TrimWavFile(reader, writer, startPos, endPos);\n                    }\n                }\n            }\n\n            private static void TrimWavFile(WaveFileReader reader, WaveFileWriter writer, int startPos, int endPos)\n            {\n                reader.Position = startPos;\n                byte[] buffer = new byte[endPos - startPos];\n                while (reader.Position &lt; endPos)\n                {\n                    int bytesRequired = (int)(endPos - reader.Position);\n                    if (bytesRequired &gt; 0)\n                    {\n                        int bytesToRead = Math.Min(bytesRequired, buffer.Length);\n                        int bytesRead = reader.Read(buffer, 0, bytesToRead);\n                        if (bytesRead &gt; 0)\n                        {\n                            writer.WriteData(buffer, 0, bytesRead);\n                        }\n                    }\n                }\n            }\n        }\n\n\n        public static class Reverse\n        {\n            public static void ReverseWaveFile(string inputFile, string outputFile)\n            {\n                using (WaveFileReader reader = new WaveFileReader(inputFile))\n                {\n                    int blockAlign = reader.WaveFormat.BlockAlign;\n                    using (WaveFileWriter writer = new WaveFileWriter(outputFile, reader.WaveFormat))\n                    {\n                        byte[] buffer = new byte[blockAlign];\n                        long samples = reader.Length / blockAlign;\n                        for (long sample = samples - 1; sample &gt;= 0; sample--)\n                        {\n                            reader.Position = sample * blockAlign;\n                            reader.Read(buffer, 0, blockAlign);\n                            writer.WriteData(buffer, 0, blockAlign);\n                        }\n                    }\n                }\n            }\n        }\n    }\n</code></pre>\n\nThen I use the following commands on my windows form button to trim and fade both ends:<br />\n<pre><code>Trim.TrimWavFile(@&quot;c:\\test\\Test.wav&quot;, @&quot;c:\\test\\Step1.wav&quot;, TimeSpan.FromSeconds(45), TimeSpan.FromSeconds(45));\n\n            var afr = new AudioFileReader(@&quot;c:\\test\\Step1.wav&quot;);\n            var fader = new FadeInOutSampleProvider(afr);\n            var filename = (string)@&quot;c:\\test\\Step2.wav&quot;;\n            fader.BeginFadeIn(7000);\n            var stwp = new NAudio.Wave.SampleProviders.SampleToWaveProvider(fader);\n            WaveFileWriter.CreateWaveFile(filename, stwp);\n            \n            Reverse.ReverseWaveFile(@&quot;c:\\test\\Step2.wav&quot;, @&quot;c:\\test\\Step3.wav&quot;);\n\n            var afr2 = new AudioFileReader(@&quot;c:\\test\\Step3.wav&quot;);\n            var fader2 = new FadeInOutSampleProvider(afr2);\n            var filename2 = (string)@&quot;c:\\test\\Step4.wav&quot;;\n            fader2.BeginFadeIn(10000);\n            var stwp2 = new NAudio.Wave.SampleProviders.SampleToWaveProvider(fader2);\n            WaveFileWriter.CreateWaveFile(filename2, stwp2);\n\n            Reverse.ReverseWaveFile(@&quot;c:\\test\\Step4.wav&quot;, @&quot;c:\\test\\&quot; +tbArtistName.Text+ &quot; &quot; +tbTrackTitle.Text+ &quot; &quot; +tbCatNo.Text+&quot;.wav&quot;);\n</code></pre>\n\nHope that is useful for somebody :)<br />\n",
    "PostedDate": "2014-02-20T21:18:16.187-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]