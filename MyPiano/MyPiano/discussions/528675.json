[
  {
    "Id": "1201808",
    "ThreadId": "528675",
    "Html": "Hi,\r<br />\n<br />\nI have coded two methods of audio into my game engine based on NAudio.<br />\n<ol>\n<li>Create a WaveOutEvent object every time a sound needs to be be played.</li>\n<li>\nCreate arrays of WaveOutEvent objects already initialised to play certain sounds. The play method checks the array to detect the first player in the array which is not stopped, and plays it.<br />\n</li>\n</ol>\nOk, so neither of these work yet. I need some advice!<br />\n<h1>Details on 1:</h1>\nThe play sound method uses a string variable 'path', which contains the path of the wav file to be played.<br />\n<pre><code>                if(mode == &quot;SINGLE&quot;)\n                {\n                    WaveOutEvent wavePlayer1;\n                    AudioFileReader file1;\n                    \n                    wavePlayer1 = new WaveOutEvent();\n                    file1 = new AudioFileReader(path);\n                    wavePlayer1.Init(file1);\n                    wavePlayer1.Play();                     \n                }</code></pre>\n\nThe sound plays once, but when I attempt to play the second time I get the error &quot;Error: Already allocated calling waveOutOpen&quot;. This confuses me since a new WaveOutEvent object local to the block of code is created and played, meaning subsequent objects are new objects - not the same. Is that right?<br />\n<h1>Details on 2:</h1>\nThe initialisation code called at the start of the game engine is pretty basic:<br />\n<pre><code>                    // Array of players ----------------------------------------\n                    NAudio_EATEN_GHOST_Array = new WaveOutEvent[noOfPlayers];\n                    NAudio_EATEN_PILL_Array = new WaveOutEvent[noOfPlayers];\n                    NAudio_EATEN_POWERPILL_Array = new WaveOutEvent[noOfPlayers];\n                    NAudio_KILLED_BY_GHOST_Array = new WaveOutEvent[noOfPlayers];   \n                    \n                    AudioFileReader file;\n                    \n                    for(int i=0;i&lt;NAudio_EATEN_GHOST_Array.Length;i++)\n                    {\n                        NAudio_EATEN_GHOST_Array[i] = new WaveOutEvent();\n                        file = new AudioFileReader(&quot;D:\\\\Programming\\\\SFX\\\\EATEN_GHOST\\\\Hit_55.wav&quot;);\n                        NAudio_EATEN_GHOST_Array[i].Init(file);\n                        \n                        NAudio_EATEN_PILL_Array[i] = new WaveOutEvent();\n                        file = new AudioFileReader(&quot;D:\\\\Programming\\\\SFX\\\\EATEN_PILL\\\\Hit_43_s.wav&quot;);\n                        NAudio_EATEN_PILL_Array[i].Init(file);\n        \n                        NAudio_EATEN_POWERPILL_Array[i] = new WaveOutEvent();\n                        file = new AudioFileReader(&quot;D:\\\\Programming\\\\SFX\\\\EATEN_POWERPILL\\\\Hit_49.wav&quot;);        \n                        NAudio_EATEN_POWERPILL_Array[i].Init(file);\n    \n                        NAudio_KILLED_BY_GHOST_Array[i] = new WaveOutEvent();\n                        file = new AudioFileReader(&quot;D:\\\\Programming\\\\SFX\\\\KILLED_BY_GHOST\\\\Hit_72.wav&quot;);\n                        NAudio_KILLED_BY_GHOST_Array[i].Init(file);\n                    }\n                    // Array of players ----------------------------------------            </code></pre>\n\nWith the players all created, the method to play a sound includes the following code, which again is pretty basic and attempts to use the playback state event:<br />\n<pre><code>                if(mode == &quot;PLAYER_ARRAY&quot;)\n                {\n                    switch(effectsIn)\n                    {\n                        case &quot;KILLED_BY_GHOST&quot;:\n                            // 1.   Choose a media player which is not playing.\n                            i = 0;\n                            do\n                            {\n                                if(NAudio_KILLED_BY_GHOST_Array[i].PlaybackState != PlaybackState.Stopped)\n                                {\n                                    // Keep looking\n                                    i++;\n                                }\n                                else\n                                {\n                                    found = true;\n                                }\n                            } while( (i&lt;NAudio_KILLED_BY_GHOST_Array.Length) &amp;&amp; (!found));\n                            // Now 'i' holds the index of the player which is not playing.\n                            \n                            // 2.   Play effect                 \n                            if(found)\n                            {\n                                NAudio_KILLED_BY_GHOST_Array[i].Play();\n                            }\n                            break;\n                            \n                        case &quot;EATEN_PILL&quot;:\n                            // 1.   Choose a media player which is not playing.\n                            i = 0;\n                            do\n                            {\n                                MessageBox.Show(NAudio_EATEN_PILL_Array[i].PlaybackState.ToString());\n                                if(NAudio_EATEN_PILL_Array[i].PlaybackState != PlaybackState.Stopped)\n                                {\n                                    // Keep looking\n                                    i++;\n                                }\n                                else\n                                {\n                                    found = true;\n                                }\n                            } while( (i&lt;NAudio_EATEN_PILL_Array.Length) &amp;&amp; (!found));\n                            // Now 'i' holds the index of the player which is not playing.\n                            \n                            // 2.   Play effect \n                            if(found)\n                            {                   \n                                NAudio_EATEN_PILL_Array[i].Play();\n                            }\n                            \n                            break;\n                        case &quot;EATEN_GHOST&quot;:\n                            // 1.   Choose a media player which is not playing.\n                            i = 0;\n                            do\n                            {\n                                if(NAudio_EATEN_GHOST_Array[i].PlaybackState != PlaybackState.Stopped)\n                                {\n                                    // Keep looking\n                                    i++;\n                                }\n                                else\n                                {\n                                    found = true;\n                                }\n                            } while( (i&lt;NAudio_EATEN_GHOST_Array.Length) &amp;&amp; (!found));\n                            // Now 'i' holds the index of the player which is not playing.\n                            \n                            // 2.   Play effect                 \n                            if(found)\n                            {\n                                NAudio_EATEN_GHOST_Array[i].Play(); \n                            }\n                            break;\n                        case &quot;EATEN_POWERPILL&quot;:\n                            // 1.   Choose a media player which is not playing.\n                            i = 0;\n                            do\n                            {\n                                if(NAudio_EATEN_POWERPILL_Array[i].PlaybackState != PlaybackState.Stopped)\n                                {\n                                    // Keep looking\n                                    i++;\n                                }\n                                else\n                                {\n                                    found = true;\n                                }\n                            } while( (i&lt;NAudio_EATEN_POWERPILL_Array.Length) &amp;&amp; (!found));\n                            // Now 'i' holds the index of the player which is not playing.\n                            \n                            // 2.   Play effect                 \n                            if(found)\n                            {\n                                NAudio_EATEN_POWERPILL_Array[i].Play();\n                            }\n                            break;\n                    } // switch             \n                }</code></pre>\n\nIn the case of the EATEN_PILL effect, there are 5 WaveOutEvent objects in the array. 5 sounds play successfully (noOfPlayers is 5...), but then no more. The rest of the calls give silence. The message box debug tells me that the sounds never go back to PlaybackState.Stopped. They are always 'PlaybackState.Playing'. But the sound is a second long, so how can this be?\r<br />\n<br />\nIn any case both attempts have not worked, and the code is pretty useless.\r<br />\n<br />\nAm I coming from this from the wrong angle? Is there another way to use the cleverness of the API to achieve what I need to? Argh.<br />\n",
    "PostedDate": "2014-02-02T10:20:10.79-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1209489",
    "ThreadId": "528675",
    "Html": "Check my article on fire and forget audio playback <a href=\"http://mark-dot-net.blogspot.co.uk/2014/02/fire-and-forget-audio-playback-with.html\" rel=\"nofollow\">here</a>.<br />\n",
    "PostedDate": "2014-02-17T08:05:49.157-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]