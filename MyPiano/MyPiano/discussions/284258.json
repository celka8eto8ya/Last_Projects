[
  {
    "Id": "717483",
    "ThreadId": "284258",
    "Html": "\r\n<p>Hi,</p>\r\n<p>Is there some reason ASIO input isn't supported?</p>\r\n<p>I've hacked input capability into ASIODriverExt.cs - it's only half a dozen changes and appears to work fine, but I worry that there's&nbsp;&nbsp;some reason this wasn't done in the first place.</p>\r\n<p>HF</p>\r\n",
    "PostedDate": "2011-12-27T08:30:55.003-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "717751",
    "ThreadId": "284258",
    "Html": "<p>No huge reason. The original ASIO support was a contribution, and it never worked with my soundcard until recently. There is another patch I have in my in-box to add recording, but it needs a few little tweaks before it can be merged in.</p>\r\n<p>ASIO recording isn't separate from playback like other driver models - you must deal with both outgoing and ingoing buffers in the same callback. It's a model that I really like, but it does mean that it won't quite fit with the other IWaveIn implementations.</p>",
    "PostedDate": "2011-12-28T00:04:45.533-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "718481",
    "ThreadId": "284258",
    "Html": "<p>&gt; ASIO recording isn't separate from playback like other driver models - you must deal with both outgoing and ingoing buffers in the same callback.</p>\r\n<p>&nbsp;</p>\r\n<p>Well, sure, theoretically, but there's no problem with having a callback for each and calling them sequentially, if that's what your interface definition requires.&nbsp;Personally I just hacked it up such that the one callback now gets an extra argument with the input samples, but I can appreciate you wouldn't necessarily want to do that as it'd break everyone's existing code.&nbsp;</p>\r\n<p>HF</p>",
    "PostedDate": "2011-12-29T16:30:27.727-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "822767",
    "ThreadId": "284258",
    "Html": "<p>How is this coming along? any progress in merging this? i would really like to use the ASIO inputs and i also like the idea of a callback with both in and out buffers.</p>\r\n<p>Is there any new patch available?</p>\r\n<p>best</p>",
    "PostedDate": "2012-04-12T00:29:40.363-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824240",
    "ThreadId": "284258",
    "Html": "<p>no I'm afraid you'll need to modify the AsioOut class yourself at the moment to support this. Its a feature I'd like to get into the next public NAudio release</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-04-16T00:37:55.617-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824245",
    "ThreadId": "284258",
    "Html": "<p>ok, i see... but i can't promise to get it done soon, but i will try this week.</p>\r\n<p>would it be basically like this?:</p>\r\n<p>the AsioOut would get an additional constructor which takes a class or interface which provides a method processing both, in and out buffer. the AsioOut then calls this method with the buffers.</p>\r\n<p>then we would need an adapter class implementing this interface which will take an IWaveProvider and some kind of input interface (is there something already?) to be able to use all the IWaveproviders that already exist...</p>\r\n<p>or what would you propose?</p>",
    "PostedDate": "2012-04-16T00:50:47.74-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824250",
    "ThreadId": "284258",
    "Html": "<p>well the existing interface is IWaveIn, which simply raises an event to notify you whenever audio is available. To fit with the rest of NAudio, that would be good, but the ASIO model is quite different from all other methods of recording.</p>",
    "PostedDate": "2012-04-16T00:53:50.287-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824254",
    "ThreadId": "284258",
    "Html": "<p>yes, so i think the adapter class will just do the following:</p>\r\n<p>- implements a new IAsioProcess (or whatever name) interface</p>\r\n<p>- take IWaveIn and IWaveProvider as constructor arguments</p>\r\n<p>- when the driver does the callback it first raises the event of IWaveIn and then calls the Read method of IWaveProvider</p>\r\n<p>what do you think?</p>",
    "PostedDate": "2012-04-16T00:58:50.087-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824257",
    "ThreadId": "284258",
    "Html": "<p>I'm not quite sure what you have in mind for the adapter. AsioOut has the Init method which takes an IWaveProvider at the moment. To fit with other NAudio classes, the simple thing to do would just be to make AsioOut implement IWaveIn. All you need to do is in the callback raise the event of IWaveIn.</p>",
    "PostedDate": "2012-04-16T01:04:35.137-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824259",
    "ThreadId": "284258",
    "Html": "<p>ok, that would be simple, but it would not allow users to write classes which implement a method which takes both buffers.</p>\r\n<p>for example libpd has an audio processing function like:&nbsp;<span>process_float</span>(<span>int</span>&nbsp;ticks,&nbsp;<span>ref</span>&nbsp;<span>float</span>&nbsp;inBuffer,&nbsp;<span>ref</span>&nbsp;<span>float</span>&nbsp;outBuffer)&nbsp;</p>\r\n<p>so the in and out buffer needs to be there in the same time. it would be an option to store the in buffer (or a reference to it) when getting the event and providing it to this call in the read method. i am not sure if its flexible enough.... but yea, should also be possible.</p>",
    "PostedDate": "2012-04-16T01:12:31.58-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "824262",
    "ThreadId": "284258",
    "Html": "<p>that is a good point. one callback function for in and out can be very useful</p>",
    "PostedDate": "2012-04-16T01:18:06.63-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "830717",
    "ThreadId": "284258",
    "Html": "<blockquote style=\"border: 0.1em solid #cccccc; font-style: italic; margin: 0.25em 1em 0pt; padding: 0pt 0.25em;\"><strong>Hfuy wrote:</strong><br />\r\n<p>Hi,</p>\r\n<p>Is there some reason ASIO input isn't supported?</p>\r\n<p>I've hacked input capability into ASIODriverExt.cs - it's only half a dozen changes and appears to work fine, but I worry that there's&nbsp;&nbsp;some reason this wasn't done in the first place.</p>\r\n<p>HF</p>\r\n</blockquote>\r\n<p>Hi Hfuy,</p>\r\n<p>&nbsp;</p>\r\n<p>Could you describe exactly which hacks you made to ASIODriverExt.cs to get ASIO input working? I would love to see this feature added to NAudio in the future but for now if I would be happy with a work-around.</p>\r\n<p>Thanks!</p>",
    "PostedDate": "2012-05-01T10:02:33.217-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "837426",
    "ThreadId": "284258",
    "Html": "\r\n<p>Hi,</p>\r\n<p>Based on a recent request:</p>\r\n<p>Sorry it's taken a while to get around to this, but here's what I did. It probably isn't good style with respect to the rest of naudio and it's based on what may now be a pretty old revision of the code, but this is most of what I had to do. It's also been\r\n ages since I worked on this so my ability to help out with it may be limited.</p>\r\n<p>It expands outputBufferInfos with additional entries for input. outputBufferInfos is now misnamed, but it shouldn't be a breaking change as the output buffers are still at the same indices in the array; the appropriate solution is probably to create a new\r\n bufferInfos array and deprecate outputBufferInfos (but assign it to bufferInfos for back compat). Then it'll need wrapping up to support all the appropriate interfaces, but that's beyond me. Otherwise, just listen for&nbsp;ASIOFillBufferCallback, observe the\r\n buffer index and read the latter half of the outputBufferInfos array.</p>\r\n<p>In short, it's a terrible hack job. Anyway, here it is.</p>\r\n<p>PS - I think this is all you need. I did make changes to other files, but only so as to be make the ASIO driver standalone from the rest of naudio (it didn't take much). I honestly can't remember if this file alone is enough, but I can make the rest of it\r\n available if need be.</p>\r\n<p>[Incorrect code redacted - see post below for code]</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>\n</pre>\r\n</div>\r\n",
    "PostedDate": "2012-05-16T14:28:10.1-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "838066",
    "ThreadId": "284258",
    "Html": "<p>thanks for this, I'll refer back to this when I get round to adding ASIO in support which is long overdue</p>",
    "PostedDate": "2012-05-18T01:38:16.953-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "843209",
    "ThreadId": "284258",
    "Html": "<p>Hi <a class=\"UserProfileLink\" href=\"http://www.codeplex.com/site/users/view/Hfuy\">Hfuy</a></p>\r\n<p>&nbsp;</p>\r\n<p>First of all, thanks very much for the response! I was a bit confused though. I have an unchanged version of NAudio 1.5 and when I compare the code you posted with my ASIODriverExt.cs in araxis merge I see that they are 100 percent identical. Did you perhaps grab the un-hacked file by accident?</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks for your time!</p>",
    "PostedDate": "2012-05-31T09:32:49.593-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "857827",
    "ThreadId": "284258",
    "Html": "<p>Hi,</p>\r\n<p>&nbsp; If you don't mind posting the Hacked ASIODriverExt.cs with your changes for ASIO recording.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks in advance</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-07-05T05:40:38.14-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "857956",
    "ThreadId": "284258",
    "Html": "\r\n<p><span>&gt; Did you perhaps grab the un-hacked file by accident?</span></p>\r\n<p>What d'you think I am, some sort of idi...</p>\r\n<p>...oh yeah, I <em>am</em> an idiot. Sorry, folks, my bad.</p>\r\n<p>Anyway, here it is. I did just test this out and it is working, at least in the context of my own code.&nbsp;The purpose of this change, by the way, was to write an SMPTE timecode decoder. This is also working, and if there's any interest in naudio being\r\n able to decode SMPTE timecode, I might be persuaded to donate it.</p>\r\n<pre><div style=\"color:black; background-color:white\"><pre><span style=\"color:blue\">using</span> System;\n\n<span style=\"color:blue\">namespace</span> NAudio.Wave.Asio\n{\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> ASIODriverCapability holds all the information from the ASIODriver.</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> Use ASIODriverExt to get the Capabilities</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:blue\">internal</span> <span style=\"color:blue\">class</span> ASIODriverCapability\n    {\n        <span style=\"color:blue\">public</span> String DriverName;  \n      \n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> NbInputChannels;\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> NbOutputChannels;\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> InputLatency;\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> OutputLatency;\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> BufferMinSize;\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> BufferMaxSize;\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> BufferPreferredSize;\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> BufferGranularity;\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">double</span> SampleRate;\n\n        <span style=\"color:blue\">public</span> ASIOChannelInfo[] InputChannelInfos;\n        <span style=\"color:blue\">public</span> ASIOChannelInfo[] OutputChannelInfos;\n    }\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> Callback used by the ASIODriverExt to get wave data</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:blue\">internal</span> <span style=\"color:blue\">delegate</span> <span style=\"color:blue\">void</span> ASIOFillBufferCallback(IntPtr[] InputBufferChannels, IntPtr[] OutputBufferChannels);\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> ASIODriverExt is a simplified version of the ASIODriver. It provides an easier</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> way to access the capabilities of the Driver and implement the callbacks necessary </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> for feeding the driver.</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> Implementation inspired from Rob Philpot's with a managed C&#43;&#43; ASIO wrapper BlueWave.Interop.Asio</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> http://www.codeproject.com/KB/mcpp/Asio.Net.aspx</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> Contributor: Alexandre Mutel - email: alexandre_mutel at yahoo.fr</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> ASIO input hacked in by: Phil Rhodes</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> This is currently extremely basic and breaks the previous API in several</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> places. See http://naudio.codeplex.com/discussions/284258</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> Changes are particularly in CreateBuffers and BufferSwitchCallback.</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> The underlying driver in ASIODriver.cs does not seem to need changes to</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> support input.</span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n    <span style=\"color:blue\">internal</span> <span style=\"color:blue\">class</span> ASIODriverExt\n    {\n        <span style=\"color:blue\">private</span> ASIODriver driver;\n        <span style=\"color:blue\">private</span> ASIOCallbacks callbacks;\n        <span style=\"color:blue\">private</span> ASIODriverCapability capability;\n        <span style=\"color:blue\">public</span> ASIOBufferInfo[] BufferInfos;\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">bool</span> isOutputReadySupport;\n        <span style=\"color:blue\">private</span> IntPtr[] CurrentOutputBuffers;\n        <span style=\"color:blue\">private</span> IntPtr[] CurrentInputBuffers;\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> nbOutputChannels;\n        <span style=\"color:blue\">private</span> ASIOFillBufferCallback BuffersReadyCallback;\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> bufferSize;\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> channelOffset;\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Initializes a new instance of the  class based on an already</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> instantiated ASIODriver instance.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> A ASIODriver already instantiated.</span>\n        <span style=\"color:blue\">public</span> ASIODriverExt(ASIODriver driver)\n        {\n            <span style=\"color:blue\">this</span>.driver = driver;\n\n            <span style=\"color:blue\">if</span> (!driver.init(IntPtr.Zero))\n            {\n                <span style=\"color:blue\">throw</span> <span style=\"color:blue\">new</span> ApplicationException(driver.getErrorMessage());\n            }\n\n            callbacks = <span style=\"color:blue\">new</span> ASIOCallbacks();\n            callbacks.pasioMessage = AsioMessageCallBack;\n            callbacks.pbufferSwitch = BufferSwitchCallBack;\n            callbacks.pbufferSwitchTimeInfo = BufferSwitchTimeInfoCallBack;\n            callbacks.psampleRateDidChange = SampleRateDidChangeCallBack;\n\n            BuildCapabilities();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Allows adjustment of which is the first output channel we write to</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Channel offset</span>\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> SetChannelOffset(<span style=\"color:blue\">int</span> channelOffset)\n        {\n            <span style=\"color:blue\">if</span> (channelOffset &#43; nbOutputChannels &lt;= Capabilities.NbOutputChannels)\n            {\n                <span style=\"color:blue\">this</span>.channelOffset = channelOffset;\n            }\n            <span style=\"color:blue\">else</span>\n            {\n                <span style=\"color:blue\">throw</span> <span style=\"color:blue\">new</span> ArgumentException(<span style=\"color:#a31515\">&quot;Invalid channel offset&quot;</span>);\n            }\n       }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Gets the driver used.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The ASIOdriver.</span>\n        <span style=\"color:blue\">public</span> ASIODriver Driver\n        {\n            <span style=\"color:blue\">get</span> { <span style=\"color:blue\">return</span> driver; }\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Starts playing the buffers.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> Start()\n        {\n            driver.start();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Stops playing the buffers.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> Stop()\n        {\n            driver.stop();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Shows the control panel.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> ShowControlPanel()\n        {\n            driver.controlPanel();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Releases this instance.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> ReleaseDriver()\n        {\n            <span style=\"color:blue\">try</span>\n            {\n                driver.disposeBuffers();\n            } <span style=\"color:blue\">catch</span> (Exception ex)\n            {\n                Console.Out.WriteLine(ex.ToString());\n            }\n            driver.ReleaseComASIODriver();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Determines whether the specified sample rate is supported.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The sample rate.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> \ttrue if [is sample rate supported]; otherwise, false.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">bool</span> IsSampleRateSupported(<span style=\"color:blue\">double</span> sampleRate)\n        {\n            <span style=\"color:blue\">return</span> driver.canSampleRate(sampleRate);\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Sets the sample rate.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The sample rate.</span>\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> SetSampleRate(<span style=\"color:blue\">double</span> sampleRate)\n        {\n            driver.setSampleRate(sampleRate);\n            <span style=\"color:green\">// Update Capabilities</span>\n            BuildCapabilities();\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Gets or sets the fill buffer callback.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The fill buffer callback.</span>\n        <span style=\"color:blue\">public</span> ASIOFillBufferCallback FillBufferCallback\n        {\n            <span style=\"color:blue\">get</span> { <span style=\"color:blue\">return</span> BuffersReadyCallback; }\n            <span style=\"color:blue\">set</span> { BuffersReadyCallback = value; }\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Gets the capabilities of the ASIODriver.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The capabilities.</span>\n        <span style=\"color:blue\">public</span> ASIODriverCapability Capabilities\n        {\n            <span style=\"color:blue\">get</span> { <span style=\"color:blue\">return</span> capability; }\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Creates the buffers for playing.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The number of outputs channels.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> if set to true [use max buffer size] else use Prefered size</span>\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">int</span> CreateBuffers(<span style=\"color:blue\">int</span> nbInputChannelsArg, <span style=\"color:blue\">int</span> nbOutputChannelsArg, <span style=\"color:blue\">bool</span> useMaxBufferSize)\n        {\n            <span style=\"color:blue\">if</span> (nbOutputChannelsArg &lt;= 0 || nbOutputChannelsArg &gt; capability.NbOutputChannels)\n            {\n                <span style=\"color:blue\">throw</span> <span style=\"color:blue\">new</span> ArgumentException(String.Format(\n                                                <span style=\"color:#a31515\">&quot;Invalid number of channels {0}, must be in the range [1,{1}]&quot;</span>,\n                                                nbOutputChannelsArg, capability.NbOutputChannels));\n            }\n\n            <span style=\"color:green\">// each channel needs a buffer info</span>\n            nbOutputChannels = nbOutputChannelsArg;\n            <span style=\"color:green\">// Ask for maximum of output channels even if we use only the nbOutputChannelsArg</span>\n            <span style=\"color:blue\">int</span> nbTotalChannels = capability.NbInputChannels &#43; capability.NbOutputChannels;\n            BufferInfos = <span style=\"color:blue\">new</span> ASIOBufferInfo[nbTotalChannels];\n            CurrentOutputBuffers = <span style=\"color:blue\">new</span> IntPtr[nbOutputChannelsArg];\n            CurrentInputBuffers = <span style=\"color:blue\">new</span> IntPtr[nbInputChannelsArg];\n            <span style=\"color:green\">// and do the same for output channels</span>\n            <span style=\"color:green\">// ONLY work on output channels (just put isInput = true for InputChannel)</span>\n            <span style=\"color:blue\">int</span> totalIndex = 0;\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> index = 0; index &lt; capability.NbInputChannels; index&#43;&#43;, totalIndex&#43;&#43;)\n            {\n                BufferInfos[totalIndex].isInput = <span style=\"color:blue\">true</span>;\n                BufferInfos[totalIndex].channelNum = index;\n                BufferInfos[totalIndex].pBuffer0 = IntPtr.Zero;\n                BufferInfos[totalIndex].pBuffer1 = IntPtr.Zero;\n            }\n\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> index = 0; index &lt; capability.NbOutputChannels; index&#43;&#43;, totalIndex&#43;&#43;)\n            {\n                BufferInfos[totalIndex].isInput = <span style=\"color:blue\">false</span>;\n                BufferInfos[totalIndex].channelNum = index;\n                BufferInfos[totalIndex].pBuffer0 = IntPtr.Zero;\n                BufferInfos[totalIndex].pBuffer1 = IntPtr.Zero;\n            }\n\n            <span style=\"color:blue\">if</span> (useMaxBufferSize)\n            {\n                <span style=\"color:green\">// use the drivers maximum buffer size</span>\n                bufferSize = capability.BufferMaxSize;\n            }\n            <span style=\"color:blue\">else</span>\n            {\n                <span style=\"color:green\">// use the drivers preferred buffer size</span>\n                bufferSize = capability.BufferPreferredSize;\n            }\n\n            <span style=\"color:blue\">unsafe</span>\n            {\n                <span style=\"color:blue\">fixed</span> (ASIOBufferInfo* infos = &amp;BufferInfos[0])\n                {\n                    IntPtr pOutputBufferInfos = <span style=\"color:blue\">new</span> IntPtr(infos);\n\n                    <span style=\"color:green\">// Create the ASIO Buffers with the callbacks</span>\n\n                    driver.createBuffers(pOutputBufferInfos, nbTotalChannels, bufferSize, <span style=\"color:blue\">ref</span> callbacks);\n                }\n            }\n\n            <span style=\"color:green\">// Check if outputReady is supported</span>\n            isOutputReadySupport = (driver.outputReady() == ASIOError.ASE_OK);\n            \n            <span style=\"color:blue\">return</span> bufferSize;\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Builds the capabilities internally.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> BuildCapabilities()\n        {\n            capability = <span style=\"color:blue\">new</span> ASIODriverCapability();\n\n            capability.DriverName = driver.getDriverName();\n\n            <span style=\"color:green\">// Get nb Input/Output channels</span>\n            driver.getChannels(<span style=\"color:blue\">out</span> capability.NbInputChannels, <span style=\"color:blue\">out</span> capability.NbOutputChannels);\n\n            capability.InputChannelInfos = <span style=\"color:blue\">new</span> ASIOChannelInfo[capability.NbInputChannels];\n            capability.OutputChannelInfos = <span style=\"color:blue\">new</span> ASIOChannelInfo[capability.NbOutputChannels];\n\n            <span style=\"color:green\">// Get ChannelInfo for Inputs</span>\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = 0; i &lt; capability.NbInputChannels; i&#43;&#43;)\n            {\n                capability.InputChannelInfos[i] = driver.getChannelInfo(i, <span style=\"color:blue\">true</span>);\n            }\n\n            <span style=\"color:green\">// Get ChannelInfo for Output</span>\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = 0; i &lt; capability.NbOutputChannels; i&#43;&#43;)\n            {\n                capability.OutputChannelInfos[i] = driver.getChannelInfo(i, <span style=\"color:blue\">false</span>);\n            }\n\n            <span style=\"color:green\">// Get the current SampleRate</span>\n            capability.SampleRate = driver.getSampleRate();\n\n\n            <span style=\"color:green\">// Get Latencies</span>\n            driver.getLatencies(<span style=\"color:blue\">out</span> capability.InputLatency, <span style=\"color:blue\">out</span> capability.OutputLatency);\n\n            <span style=\"color:green\">// Get BufferSize</span>\n            driver.getBufferSize(<span style=\"color:blue\">out</span> capability.BufferMinSize, <span style=\"color:blue\">out</span> capability.BufferMaxSize, <span style=\"color:blue\">out</span> capability.BufferPreferredSize, <span style=\"color:blue\">out</span> capability.BufferGranularity);\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Callback called by the ASIODriver on fill buffer demand. Redirect call to external callback.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Index of the double buffer.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> if set to true [direct process].</span>\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> BufferSwitchCallBack(<span style=\"color:blue\">int</span> doubleBufferIndex, <span style=\"color:blue\">bool</span> directProcess)\n        {\n\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = 0; i &lt; capability.NbInputChannels; i&#43;&#43;)\n            {\n                CurrentInputBuffers[i] = BufferInfos[i &#43; channelOffset].Buffer(doubleBufferIndex);\n            }\n\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = 0; i &lt; nbOutputChannels; i&#43;&#43;)\n            {\n                CurrentOutputBuffers[i] = BufferInfos[i &#43; channelOffset &#43; capability.NbInputChannels].Buffer(doubleBufferIndex);\n            }\n\n            <span style=\"color:blue\">if</span> (BuffersReadyCallback != <span style=\"color:blue\">null</span>)\n\n                BuffersReadyCallback(CurrentInputBuffers, CurrentOutputBuffers);\n\n            <span style=\"color:blue\">if</span> (isOutputReadySupport)\n                driver.outputReady();            \n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Callback called by the ASIODriver on event &quot;Samples rate changed&quot;.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The sample rate.</span>\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">void</span> SampleRateDidChangeCallBack(<span style=\"color:blue\">double</span> sRate)\n        {\n            <span style=\"color:green\">// Check when this is called?</span>\n            capability.SampleRate = sRate;\n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Asio message call back.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The selector.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The value.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The message.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The opt.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> AsioMessageCallBack(ASIOMessageSelector selector, <span style=\"color:blue\">int</span> value, IntPtr message, IntPtr opt)\n        {\n            <span style=\"color:green\">// Check when this is called?</span>\n            <span style=\"color:blue\">switch</span> (selector)\n            {\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioSelectorSupported:\n                    ASIOMessageSelector subValue = (ASIOMessageSelector)Enum.ToObject(<span style=\"color:blue\">typeof</span>(ASIOMessageSelector), value);\n                    <span style=\"color:blue\">switch</span> (subValue)\n                    {\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioEngineVersion:\n                            <span style=\"color:blue\">return</span> 1;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioResetRequest:\n                            <span style=\"color:blue\">return</span> 0;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioBufferSizeChange:\n                            <span style=\"color:blue\">return</span> 0;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioResyncRequest:\n                            <span style=\"color:blue\">return</span> 0;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioLatenciesChanged:\n                            <span style=\"color:blue\">return</span> 0;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioSupportsTimeInfo:\n<span style=\"color:green\">//                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.</span>\n                            <span style=\"color:blue\">return</span> 0;\n                        <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioSupportsTimeCode:\n<span style=\"color:green\">//                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.</span>\n                            <span style=\"color:blue\">return</span> 0;\n                    }\n                    <span style=\"color:blue\">break</span>;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioEngineVersion:\n                    <span style=\"color:blue\">return</span> 2;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioResetRequest:\n                    <span style=\"color:blue\">return</span> 1;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioBufferSizeChange:\n                    <span style=\"color:blue\">return</span> 0;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioResyncRequest:\n                    <span style=\"color:blue\">return</span> 0;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioLatenciesChanged:\n                    <span style=\"color:blue\">return</span> 0;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioSupportsTimeInfo:\n                    <span style=\"color:blue\">return</span> 0;\n                <span style=\"color:blue\">case</span> ASIOMessageSelector.kAsioSupportsTimeCode:\n                    <span style=\"color:blue\">return</span> 0;\n            }\n            <span style=\"color:blue\">return</span> 0;            \n        }\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Buffers switch time info call back.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> The asio time param.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> Index of the double buffer.</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> if set to true [direct process].</span>\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> </span>\n        <span style=\"color:blue\">private</span> IntPtr BufferSwitchTimeInfoCallBack(IntPtr asioTimeParam, <span style=\"color:blue\">int</span> doubleBufferIndex, <span style=\"color:blue\">bool</span> directProcess)\n        {\n            <span style=\"color:green\">// Check when this is called?</span>\n            <span style=\"color:blue\">return</span> IntPtr.Zero;   \n        }\n    }\n}\n</pre>\n</div>\n</pre>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2012-07-05T09:54:45.34-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "858063",
    "ThreadId": "284258",
    "Html": "<p>Thanks for the update Hfuy! You're right there's not too much added here, I will try your changes in my code and see if I can't get the ASIO input working.</p>\r\n<p>&nbsp;</p>\r\n<p>Cheers!</p>\r\n<p>Mark</p>",
    "PostedDate": "2012-07-05T14:06:11.48-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "858179",
    "ThreadId": "284258",
    "Html": "<p>Hi Hfuy,</p>\r\n<p>&nbsp; Thank you for the update, how to implement this function&nbsp;BuffersReadyCallback(CurrentInputBuffers, CurrentOutputBuffers). It would be really helpful if you post the all the&nbsp;dependent&nbsp;function implementations. How to give a specific Input channel number for recording , I am not clear with this things any ideas would be helpful.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks in advance</p>",
    "PostedDate": "2012-07-05T21:09:54.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "858267",
    "ThreadId": "284258",
    "Html": "\r\n<p>Sorry about the formatting in this, this forum software is an absolute nightmare!</p>\r\n<p>Anyway, there are a couple of stages to this.</p>\r\n<p>First, enumerate the available ASIO devices:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre style=\"color:black\"><span style=\"color:blue\">string</span>[] names = ASIODriver.GetASIODriverNames();\n<span style=\"color:blue\">foreach</span>(<span style=\"color:blue\">string</span> name <span style=\"color:blue\">in</span> names){</pre>\r\n<pre style=\"color:black\"><span style=\"white-space:pre\">\t</span>ASIODriver d = ASIODriver.GetASIODriverByName(name);</pre>\r\n<pre><span style=\"color:green\"><span style=\"white-space:pre\">\t</span>// Make visible names of ASIO drivers and figure out which one you want</span></pre>\r\n<pre><span style=\"color:green\">}</span>\n\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Pick the one you want (assuming you want the first listed):</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">int</span> WhichAsioDevice = 0;\n\nASIODriver drv = ASIODriver.GetASIODriverByName(ASIODriver.GetASIODriverNames()[WhichAsioDevice]);\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Get an ASIODriverExt instance for it:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>ASIODriverExt drvx = <span style=\"color:blue\">new</span> ASIODriverExt(drv);\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p><br>\r\n<br>\r\nSet up and start:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>ASIOFillBufferCallback cbk = <span style=\"color:blue\">new</span> ASIOFillBufferCallback(BufFeeder); <span style=\"color:green\">// See below</span>\n\ndrvx.FillBufferCallback = cbk;\n\ndrvx.CreateBuffers(drvx.Capabilities.NbInputChannels, drvx.Capabilities.NbOutputChannels, <span style=\"color:blue\">false</span>);\ndrvx.Start();\n</pre>\r\n</div>\r\n<p><br>\r\nHere's the buffer feeder (and, now, reader) callback:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre style=\"color:black\"><span style=\"color:blue\">private</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">void</span> BufFeeder(IntPtr[] InputBufferChannels, IntPtr[] OutputBufferChannels)</pre>\r\n<pre style=\"color:black\">{&nbsp;</pre>\r\n<pre><span style=\"color:blue\"><span style=\"white-space:pre\">\t</span>int</span> InputChannel = 3; <span style=\"color:green\">// This happens to be the back panel line input on my PC</span>\n<span style=\"color:blue\"><span style=\"white-space:pre\">\t</span>unsafe</span></pre>\r\n<pre><span style=\"white-space:pre\">\t</span> {</pre>\r\n<pre><span style=\"white-space:pre\">\t\t</span>Int32* InBuf = (Int32*)InputBufferChannels[InputChannel];</pre>\r\n<pre><span style=\"color:green\"><span style=\"white-space:pre\">\t\t</span>// Do something with 512 bytes of *InBuf</span>\n<span style=\"white-space:pre\">\t</span>}\n}</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>That should be enough to get you going!</p>\r\n<p><br>\r\nHF</p>\r\n",
    "PostedDate": "2012-07-06T03:19:23.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "859621",
    "ThreadId": "284258",
    "Html": "<p><span>Hi Hfuy,</span></p>\r\n<p>&nbsp; &nbsp;Thank you for the posting, is there any easy way to convert that InBuf to .wav file. If I have given the filename the inBuf should be saved to the filename.wav file. Please help me in this regard. Any sample code would be helpful.</p>\r\n<p>&nbsp;</p>\r\n<p>Thanks in advance.</p>\r\n<p><span><br /></span></p>",
    "PostedDate": "2012-07-10T05:08:30.113-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "859627",
    "ThreadId": "284258",
    "Html": "<p>Sorry, I can't really help you - I used the data in other parts of my software, and never needed to send it to a file. Presumably there is a way to do this in naudio; I found a few promising hits with a simple google search:</p>\r\n<p>&nbsp;</p>\r\n<p><a href=\"http://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ie=UTF-8#hl=en&amp;output=search&amp;sclient=psy-ab&amp;q=naudio%20save%20wave%20file&amp;oq=&amp;gs_l=&amp;pbx=1&amp;fp=42bc37e02999c64c&amp;bav=on.2,or.r_gc.r_pw.r_qf.,cf.osb&amp;biw=960&amp;bih=541\"><a href=\"http://www.google.co.uk/#hl=en&amp;sa=X&amp;ei=eh38T_eHJYWL8gOqlcmRBw&amp;ved=0CEIQvwUoAQ&amp;q=naudio+save+wav+file&amp;spell=1&amp;bav=on.2,or.r_gc.r_pw.r_qf.,cf.osb&amp;fp=42bc37e02999c64c&amp;biw=960&amp;bih=569\">http://www.google.co.uk/#hl=en&amp;sa=X&amp;ei=eh38T_eHJYWL8gOqlcmRBw&amp;ved=0CEIQvwUoAQ&amp;q=naudio+save+wav+file&amp;spell=1&amp;bav=on.2,or.r_gc.r_pw.r_qf.,cf.osb&amp;fp=42bc37e02999c64c&amp;biw=960&amp;bih=569</a></a></p>",
    "PostedDate": "2012-07-10T05:18:34.843-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "910183",
    "ThreadId": "284258",
    "Html": "<p>Just wanted to say that I've checked in ASIO recording, basing a lot of the code off Hfuy's implementation, so thanks very much for sharing</p>",
    "PostedDate": "2012-09-09T09:21:11.99-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]