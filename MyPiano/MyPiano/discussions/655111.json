[
  {
    "Id": "1474772",
    "ThreadId": "655111",
    "Html": "Hi,\r<br />\n<br />\nHave talked about this some years back i think.\r<br />\n<br />\nBut well when i am recording, even with 1000ms buffer with Wasapi,\r<br />\nif the system is under heavy load it will skip.\r<br />\n<br />\nNow there are 2 solutions for this, one is making sure it doesn't skip (not sure if it can be done?).\r<br />\nOther is pushing out Silent data when audio is skipped to make up for the lost data (hence keeping to correct timeline).\r<br />\n<br />\nSo while the skipping is important to get rid of if possible, the most important thing is the timeline.\r<br />\n<br />\nI know you can do this by using either the CPU QPC and sync to that clock, or use the Audio QPC and sync to that.\r<br />\nAnd by Sync i mean push silent data or remove data in order to keep the same time.\r<br />\n<br />\nWith Audio QPC it will most likely only be Pushing silent data though as it runs the same as the actual data anyway.\r<br />\n<br />\nProblem with Audio QPC in my case is that one of them is an USB Device, and USB isn't hardware level, it's operated by CPU interruptions, so even whe Audio QPC can be affected by heavy load, though it's the data that first get affected, the QPC can survive a bit more.\r<br />\n<br />\nCPU QPC is ideal in that sense as it's unaffected by load, problem is one needs to skip and push,\r<br />\nthis would be great in my case as it would sync the audio during recording (sync to the PC clock which i need to do anyway).\r<br />\nThough one loses a bit of data rather than the resampling later way (not in the topic).\r<br />\n<br />\n<br />\nSo i wonder what can be done?\r<br />\n<br />\nI have played around A Lot with the idea, and while i have gotten it somewhat to work at times, it's never perfect and has issues.\r<br />\n<br />\nHere is some of the code i played around with, was quite awhile ago so not sure what works as it's all commented out now.\r<br />\nBut you can probably grasp the idea of what i am trying to do more or less (it's a mess).<br />\n<pre><code>        long DevicePosition, TimeQPC, LastQPC = 0, CurrentQPC = 0;\n        int framesAvailable, CurrentSize = 0;\n        public long getStartQPC() =&gt; LastQPC;\n        public void setStartQPC(long d) =&gt; LastQPC = d;\n        int recordsize = 0;\n        int MSDiff = 0;\n        bool first = false, test;\n        int silence = 0;\n        private void ReadNextPacket(AudioCaptureClient capture)\n        {\n            int packetSize = capture.GetNextPacketSize();\n            int recordBufferOffset = 0;\n\n\n\n            //Debug.WriteLine(string.Format(&quot;packet size: {0} samples&quot;, packetSize / 4));\n\n            while (packetSize != 0)\n            {\n\n\n                AudioClientBufferFlags flags;\n\n                IntPtr buffer = capture.GetBuffer(out framesAvailable, out flags, out DevicePosition, out TimeQPC);\n                int bytesAvailable = framesAvailable * bytesPerFrame;\n                if (!first)\n                {\n                    first = true;\n                    CurrentSize -= framesAvailable;\n                    LastQPC = TimeQPC;\n                    CurrentSize += framesAvailable;\n                    capture.ReleaseBuffer(framesAvailable);\n                    packetSize = capture.GetNextPacketSize();\n                    continue;\n                }\n\n                //recordsize += bytesAvailable + (recordBufferOffset);\n                ////CurrentSize += framesAvailable;\n                //CurrentQPC = (TimeQPC - LastQPC);\n                //var QPCTime = TimeSpan.FromMilliseconds((CurrentQPC / 10000));\n                //var DeviceTime = TimeSpan.FromMilliseconds(DevicePosition / (framesAvailable / 10));\n                //var Time = TimeSpan.FromMilliseconds(CurrentSize / (framesAvailable / 10));\n\n                //Debug.WriteLine(&quot;QPC: &quot; + QPCTime + &quot; - DevicePosition: &quot; + DeviceTime + &quot; - CurrentSize: &quot; + Time);\n\n\n                //var difference = (long)(QPCTime.TotalMilliseconds - DeviceTime.TotalMilliseconds);\n                //if (difference &lt; -10)\n                //{\n\n                //    Debug.WriteLine(&quot;Time: &quot; + QPCTime);\n                //    Debug.WriteLine(&quot;Skipped 10ms&quot; + &quot; - Total: &quot; + MSDiff / -1 + &quot;ms&quot;);\n                //    recordsize -= recordBuffer.Length;\n                //    recordBufferOffset += bytesAvailable;\n                //    capture.ReleaseBuffer(framesAvailable);\n                //    packetSize = capture.GetNextPacketSize();\n                //    CurrentSize -= framesAvailable;\n                //    continue;\n\n                //}\n                //else\n                //if (difference &gt; 10)\n                //{\n                //    recordsize += bytesAvailable + (recordBufferOffset);\n\n                //    Debug.WriteLine(&quot;Add 10ms&quot; + &quot; - Total: &quot; + MSDiff + &quot;ms&quot;);\n                //    MSDiff += 10;\n                //    byte[] b = new byte[192 * (int)difference];\n                //    silence += b.Length / 192;\n                //    CurrentSize = ((int)Time.TotalMilliseconds + (int)difference) * (framesAvailable / 10);\n                //    Debug.WriteLine(&quot;Silence: &quot; + silence);\n                //    DataAvailable(this, new WaveInEventArgs(b, b.Length));\n\n                //    QPCTime = TimeSpan.FromMilliseconds((CurrentQPC / 10000));\n                //    Time = TimeSpan.FromMilliseconds(CurrentSize / (framesAvailable / 10));\n                //    difference = (long)(QPCTime.TotalMilliseconds - Time.TotalMilliseconds);\n                //    Debug.WriteLine(&quot;QPC: &quot; + QPCTime + &quot; - DevicePosition: &quot; + DeviceTime + &quot; - CurrentSize: &quot; + Time);\n                //    Debug.WriteLine(&quot;Difference: &quot; + difference);\n                //    capture.ReleaseBuffer(framesAvailable);\n                //    packetSize = capture.GetNextPacketSize();\n                //    CurrentSize = ((int)QPCTime.TotalMilliseconds) * (framesAvailable * 10);\n                //    return;\n\n                //}\n\n                // apparently it is sometimes possible to read more frames than we were expecting?\n                // fix suggested by Michael Feld:\n                int spaceRemaining = Math.Max(0, recordBuffer.Length - recordBufferOffset);\n                if (spaceRemaining &lt; bytesAvailable &amp;&amp; recordBufferOffset &gt; 0)\n                {\n                    if (DataAvailable != null) DataAvailable(this, new WaveInEventArgs(recordBuffer, recordBufferOffset));\n                    recordBufferOffset = 0;\n                }\n\n                // if not silence...\n                if ((flags &amp; AudioClientBufferFlags.Silent) != AudioClientBufferFlags.Silent)\n                {\n                    Marshal.Copy(buffer, recordBuffer, recordBufferOffset, bytesAvailable);\n\n                }\n                else\n                {\n\n                    Array.Clear(recordBuffer, recordBufferOffset, bytesAvailable);\n                }\n\n                recordBufferOffset += bytesAvailable;\n                capture.ReleaseBuffer(framesAvailable);\n                    packetSize = capture.GetNextPacketSize();\n                \n\n                    if (DataAvailable != null)\n                {\n                    DataAvailable(this, new WaveInEventArgs(recordBuffer, bytesAvailable));\n                }\n            }\n        }</code></pre>\n\n",
    "PostedDate": "2016-05-31T15:02:06.18-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1476920",
    "ThreadId": "655111",
    "Html": "I did have the same some time ago with an Usb device and was able to solve it by setting the priority class of my project to high somewhere at startup:<br />\n<pre><code>    Process.GetCurrentProcess.PriorityClass = ProcessPriorityClass.High\n\n</code></pre>\n\n",
    "PostedDate": "2016-06-21T00:45:30.957-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]