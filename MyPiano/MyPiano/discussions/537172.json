[
  {
    "Id": "1217917",
    "ThreadId": "537172",
    "Html": "Could someone please help with my problem.\r<br />\nIm trying to record all the time from the mic but only take and use the audio when the audio level is sufficient so like when the user is talking. Could someone provide a snippet for this problem.\r<br />\n<br />\nThanks<br />\n",
    "PostedDate": "2014-03-03T05:56:34.53-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1219940",
    "ThreadId": "537172",
    "Html": "The way i do recording:<br />\ni keep wave in recording always on, but gathering of mic data is only on user command<br />\ni send microphone wave in to buffered wave provider,<br />\nthen send buffered wave provider to my custom dsp_after_mic Effect class (which is as ISampleProvider),<br />\nwhich actually read byte[] 16 bit mic data from buffered, converts it , and outputs float[] buffer<br />\nthen dsp_after_mic is sent to mixer (MixingSampleProvider)<br />\n(if dsp_after_mic read less 16bit samples than mixer requested, remaining floats for mixer float buffer are filled with 0.0f) so it always return number of floats requested<br />\nmixer is then sent to dsp_after_mixer, and then to waveout<br />\nbut dsp_after_mixer also make fork copy of buffer and write it to another buffered wave provider called buffered_dsp_outstream_fork that is later read by encoder and by tcp if needed.<br />\n<br />\nFor mic buffered discard on overflow is true, also true for outsream_fork.<br />\nOn start of gathering mic data, i call Clear of mic buffered wave provider and add dsp_after_mic to mixer.<br />\nOn stop of gathering mic data, i remove dsp_after_mic from mixer.<br />\n<br />\nNow for your question,<br />\nmy dsp_after_mic look like this<br />\n<pre><code>    public class EffectStreamFloatMic : ISampleProvider\n    {\n        public BufferedWaveProvider source;\n        public bool reached_end = false;\n        private object effectLock = new object();\n        private object sourceLock = new object();\n        public float mic_volume;\n        public float sample_max_left = 0;\n        public float sample_max_right = 0;\n        private float l_max_up = 0;\n        private float r_max_up = 0;\n        private float l_max_down = 0;\n        private float r_max_down = 0;\n\n        public WaveFormat WaveFormat\n        {\n            get;\n            set;\n        }\n\n        //only work by expecting 16bit stereo as input!!!!\n        public EffectStreamFloatMic(BufferedWaveProvider sourceStream)\n        {\n            this.source = sourceStream;\n            WaveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100, 2);\n        }\n\n        public int Read(float[] buffer, int offset, int count)\n        {\n            int read;\n            int added_bytes;\n            int in_offset = offset * 2;\n            int in_byte_count = count * 2;\n            var in_buffer = new byte[in_byte_count];\n            lock (sourceLock)\n            {\n                read =  source.Read(in_buffer, in_offset, in_byte_count  );\n                if (read &lt;= 0) reached_end = true; else reached_end = false;  //will be appended regardless of end\n\n            }\n            {\n                lock (effectLock)\n                {\n                    Process16Bit(in_buffer, in_offset, read / 4, buffer, offset, count);\n                }\n            }\n\n            added_bytes = 0;\n            if (read &lt; in_byte_count) added_bytes = in_byte_count - read;\n            int added_samples = added_bytes / 4;\n            for (int sample = count - added_samples; sample &lt; count; sample++)\n            {\n                buffer[sample + offset] = 0.0f;\n            }\n            return count;\n        }\n\n        //processing of entire buffer once its read\n        //assuming always stereo\n        private void Process16Bit(byte[] buffer, int offset, int num_of_sample_pairs, float[] out_buffer, int out_offset, int out_sampleCount)\n        {\n            sample_max_left = 0;\n            sample_max_right = 0;\n            l_max_up = 0;\n            r_max_up = 0;\n            l_max_down = 0;\n            r_max_down = 0;\n\n            for (int sample_pair = 0; sample_pair &lt; num_of_sample_pairs ; sample_pair++)\n            {\n                //sample pair have 4 bytes, (2 bytes for left channel, 2 bytes for right channel)\n                int x = offset + (sample_pair * 4);\n                int xf = out_offset + (sample_pair * 2);\n                short sample16Left = BitConverter.ToInt16(buffer, x);\n                short sample16Right = BitConverter.ToInt16(buffer, x + 2);\n\n\n                float sample64Left = sample16Left / 32768.0f;\n                float sample64Right = sample16Right / 32768.0f;\n\n                sample64Left *= mic_volume;\n                sample64Right *= mic_volume;\n\n                if (sample64Left &lt; 0)\n                {\n                    if (sample64Left &lt; l_max_down) l_max_down = sample64Left;\n                }\n                else\n                {\n                    if (sample64Left &gt; l_max_up) l_max_up = sample64Left;\n                }\n                if (sample64Right &lt; 0)\n                {\n                    if (sample64Right &lt; r_max_down) r_max_down = sample64Right;\n                }\n                else\n                {\n                    if (sample64Right &gt; r_max_up) r_max_up = sample64Right;\n                }\n\n                sample_max_left = ((l_max_up + Math.Abs(l_max_down)) / 2);\n                sample_max_right = ((r_max_up + Math.Abs(r_max_down)) / 2);\n\n                out_buffer[xf ] = sample64Left;\n                out_buffer[xf + 1] = sample64Right;\n            }\n        }\n</code></pre>\n\nNow you can go on from here,<br />\nafter each read call of the pipeline,<br />\nyou will have sample_max_left and sample_max_right initialized that you can use as your Vu meter parameter, and in regard to its value you deice do discard entire block and rewrite it as silence or maybe even measure your maximums of signal on multiple segments of buffer.<br />\n<br />\nif you want to write block somewhere you can add this to Read() in your dsp effect class:<br />\n<pre><code>            //copy data to buffered provider that will feed to mp3 encoder or file writer\n            var byteArray = new byte[count * 4];\n            Buffer.BlockCopy(buffer, 0, byteArray, 0, buffer.Length);\n            buffered_fork.AddSamples(byteArray, 0, byteArray.Length);\n            byteArray = null;\n</code></pre>\n\nmake sure your effect class have fork buffer:<br />\n<pre><code>    public class EffectStreamFloatMix : ISampleProvider\n    {\n        public MixingSampleProvider source;\n        BufferedWaveProvider buffered_fork;\n        public float master_volume;\n        ....\n        ....\n\n        public EffectStreamFloatMix(MixingSampleProvider sourceStream, BufferedWaveProvider buffered_fork_wave_provider)\n        {\n            this.source = sourceStream;\n            this.buffered_fork = buffered_fork_wave_provider;\n        }\n\n        ....\n        ....\n    }</code></pre>\n\n",
    "PostedDate": "2014-03-06T08:54:03.883-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]