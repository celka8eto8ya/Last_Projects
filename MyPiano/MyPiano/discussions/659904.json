[
  {
    "Id": "1489208",
    "ThreadId": "659904",
    "Html": "I have customized Mark's Pianoroll2 so that you can display, edit and zoom notes based on MidiEvents.\r<br />\nI would like to post it, is this the proper place?![Image]\r<br />\n<br />\nWhen implement it looks like this:\r<br />\n(<a href=\"https://i.imgsafe.org/3ca723d9d1.jpg\" rel=\"nofollow\">https://i.imgsafe.org/3ca723d9d1.jpg</a>)\r<br />\n<br />\nIncidentally, I associate the PianoRoll not with a MidiEventCollection, as the original piano roll does, but rather with a single list of MIdiEvents (one track).  This is because for most purposes you want to view your tracks separately (which is presumably the reason for having midi type 1 files). \r<br />\n(You wouldn't want all your track note data mixed together on one piano roll)\r<br />\nSo, you create an instance of the piano roll for each track that you get when you open Naudio.Midi.MidiFile(&quot;&quot;)<br />\n",
    "PostedDate": "2016-12-03T23:54:24.827-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489809",
    "ThreadId": "659904",
    "Html": "There doesn't seem to be much activity on this discussion board, but I'll go ahead and post my code for the Piano Roll here.\r<br />\nI tried to remove elements specific to other parts of my project so that the Piano Roll can be used as is, so I hope I adjusted it correctly...  (Also, the C# is translated from VB.  One of these days I'll try to get used to curly brackets but that time as not yet arrived for me :)\r<br />\n<br />\nFirst, the XAML for the GUI:<br />\n<pre><code>&lt;UserControl x:Class=&quot;PianoRoll&quot;\n             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; \n             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; \n             mc:Ignorable=&quot;d&quot; \n             d:DesignHeight=&quot;133&quot; d:DesignWidth=&quot;413&quot; x:Name=&quot;PRoll&quot; &gt;\n        \n    &lt;Grid&gt;\n            \n                &lt;Border BorderThickness=&quot;4&quot; BorderBrush=&quot;#FF5885AA&quot; CornerRadius=&quot;4&quot; Background=&quot;#FFF7F0F0&quot;&gt;\n            &lt;DockPanel&gt;\n                &lt;DockPanel x:Name=&quot;TopDB&quot; DockPanel.Dock=&quot;Top&quot; Height=&quot;20&quot;&gt;\n                    &lt;Line HorizontalAlignment=&quot;Stretch&quot; DockPanel.Dock=&quot;Bottom&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;2&quot; X2=&quot;{Binding ElementName=TopDB, Path=ActualWidth}&quot;&gt;&lt;/Line&gt;\n                    &lt;StackPanel Width =&quot;70&quot;&gt;\n                        &lt;ComboBox x:Name=&quot;SnapToCB&quot; Margin=&quot;0, 0, 0, 2&quot; SelectedValuePath=&quot;Content&quot;&gt;\n                            &lt;ComboBoxItem Content=&quot;Snap&quot; IsSelected=&quot;True&quot; Tag=&quot;No snap&quot;/&gt;\n                            &lt;ComboBoxItem Content=&quot;1/2 note&quot; Tag=&quot;Snap to 1/2&quot;/&gt;\n                            &lt;ComboBoxItem Content=&quot;1/4 note&quot; Tag=&quot;Snap to 1/4&quot;/&gt;\n                            &lt;ComboBoxItem Content=&quot;1/8 note&quot; Tag=&quot;Snap to 1/8&quot;/&gt;\n                            &lt;ComboBoxItem Content=&quot;1/16 note&quot; Tag=&quot;Snap to 1/16&quot;/&gt;\n                        &lt;/ComboBox&gt;\n                    &lt;/StackPanel&gt;\n                    &lt;StackPanel DockPanel.Dock=&quot;Right&quot; Background=&quot;{DynamicResource {x:Static SystemColors.ControlColor}}&quot; Width=&quot;{x:Static SystemParameters.VerticalScrollBarWidth}&quot;&gt;&lt;/StackPanel&gt;\n                    &lt;ScrollViewer x:Name=&quot;ScaleScrollViewer&quot; HorizontalScrollBarVisibility=&quot;Hidden&quot; VerticalScrollBarVisibility=&quot;Disabled&quot;&gt;\n                        &lt;DockPanel&gt;\n                            &lt;Canvas x:Name=&quot;ScaleCanvas&quot; Width=&quot;{Binding ElementName=NoteCanvas, Path=ActualWidth}&quot; Background=&quot;#FFFFE6C9&quot;&gt;&lt;/Canvas&gt;\n                        &lt;Canvas x:Name=&quot;RightFillScaleCanvas&quot;&gt;&lt;/Canvas&gt;\n                        &lt;/DockPanel&gt;\n                    &lt;/ScrollViewer&gt;\n                  &lt;/DockPanel&gt;\n                \n                &lt;DockPanel x:Name=&quot;ScrollBarDB&quot; DockPanel.Dock=&quot;Bottom&quot; Height=&quot;15&quot;&gt;\n                    &lt;Label x:Name=&quot;RepLabel&quot; Margin=&quot;0, -3, 0, 0&quot; FontSize=&quot;7&quot; DockPanel.Dock=&quot;Left&quot; Width=&quot;{Binding ElementName=PianoStackPanel, Path=ActualWidth}&quot; Background=&quot;#FFC7D6CD&quot;&gt;&lt;/Label&gt;\n                    &lt;ScrollBar x:Name=&quot;RLScrollBar&quot; Orientation=&quot;Horizontal&quot; Background=&quot;#FFD4CCE6&quot;/&gt;\n                &lt;/DockPanel&gt;\n                &lt;ScrollViewer x:Name=&quot;UDScrollViewer&quot; HorizontalScrollBarVisibility=&quot;Disabled&quot; VerticalScrollBarVisibility=&quot;Auto&quot;&gt;\n                    &lt;DockPanel x:Name=&quot;MainDockPanel&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;\n                        &lt;DockPanel x:Name=&quot;PianoDockPanel&quot;  DockPanel.Dock=&quot;Left&quot; Width=&quot;70&quot; LastChildFill=&quot;False&quot;&gt;\n                            &lt;DockPanel.Background&gt;\n                                &lt;ImageBrush ImageSource=&quot;pack://siteoforigin:,,,/CustomControls/Resources/PianoLong.bmp&quot;/&gt;\n                            &lt;/DockPanel.Background&gt;\n                            &lt;Line DockPanel.Dock=&quot;Right&quot;  Y1=&quot;0&quot; Y2=&quot;{Binding ElementName=PianoStackPanel, Path=ActualHeight}&quot; X1=&quot;0&quot; X2=&quot;0&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot;&gt;\n                                &lt;Line.Fill&gt;\n                                    &lt;ImageBrush/&gt;\n                                &lt;/Line.Fill&gt;\n                            &lt;/Line&gt;\n                            &lt;Canvas x:Name=&quot;NoteNameCanvas&quot;&gt;&lt;/Canvas&gt;\n                        &lt;/DockPanel&gt;\n                        &lt;ScrollViewer x:Name=&quot;RLScrollViewer&quot; HorizontalScrollBarVisibility=&quot;Hidden&quot;  Height=&quot;{Binding ElementName=GridCanvas, Path=ActualHeight}&quot; VerticalScrollBarVisibility=&quot;Auto&quot; Background=&quot;Cornsilk&quot;&gt;\n                            \n                                &lt;Canvas x:Name=&quot;HolderCanvas&quot; VerticalAlignment=&quot;Top&quot; HorizontalAlignment=&quot;Left&quot;  &gt;\n\n                                &lt;AdornerDecorator Height=&quot;{Binding ElementName=NoteCanvas, Path=ActualHeight}&quot; Width=&quot;{Binding ElementName=NoteCanvas, Path=ActualWidth}&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot;  x:Name=&quot;MeasBufAdornerLayer&quot; Visibility=&quot;Visible&quot; &gt;\n                                    &lt;Grid&gt;\n                                        &lt;Grid.Background&gt;\n                                            &lt;LinearGradientBrush  EndPoint=&quot;1,0.5&quot; StartPoint=&quot;0,0.5&quot; &gt;\n                                                &lt;GradientStop Color=&quot;#00000000&quot; Offset=&quot;0&quot;/&gt;\n                                                &lt;GradientStop x:Name=&quot;MeasBuf1&quot; Color=&quot;#00000000&quot; Offset=&quot;1&quot;/&gt;\n                                                &lt;GradientStop x:Name=&quot;MeasBuf2&quot; Color=&quot;#917CEE6A&quot; Offset=&quot;1&quot;/&gt;\n                                                &lt;GradientStop Color=&quot;#917CEE6A&quot; Offset=&quot;1&quot;/&gt;\n                                            &lt;/LinearGradientBrush&gt;\n                                        &lt;/Grid.Background&gt;\n                                    &lt;/Grid&gt;\n                                &lt;/AdornerDecorator&gt;\n\n                                &lt;Canvas x:Name=&quot;GridCanvas&quot; Background=&quot;Transparent&quot; Top=&quot;0&quot; Left=&quot;0&quot; Height=&quot;{Binding ActualHeight, ElementName=NoteCanvas}&quot; &gt;\n                                    \n                                &lt;/Canvas&gt;\n                                &lt;Canvas x:Name=&quot;NoteCanvas&quot; Left=&quot;0&quot; Top=&quot;0&quot; Focusable=&quot;True&quot; Height=&quot;{Binding ElementName=GridCanvas, Path=ActualHeight}&quot; &gt;\n                                    &lt;Canvas.CacheMode&gt;\n                                        &lt;BitmapCache EnableClearType=&quot;False&quot;  RenderAtScale=&quot;1&quot; SnapsToDevicePixels=&quot;True&quot; /&gt;\n                                    &lt;/Canvas.CacheMode&gt;\n                                &lt;/Canvas&gt;\n                                &lt;Canvas x:Name=&quot;RightFillNoteCanvas&quot;&gt;&lt;/Canvas&gt;\n\n                            &lt;/Canvas&gt;\n                        &lt;/ScrollViewer&gt;\n                          \n                &lt;/DockPanel&gt;\n            &lt;/ScrollViewer&gt;\n            &lt;/DockPanel&gt;\n        &lt;/Border&gt;\n    &lt;/Grid&gt;\n&lt;/UserControl&gt;\n</code></pre>\n\nThis Piano Roll is associated with one track (list of MidiEvents) from a MidiEventCollection.  I did this because it seems most logical (having all note from all tracks on the same Piano Roll is huge visual mess).  So, you would create a new instance of PianoRoll for each track when you open a MidiFile.  (However, you have to set the DetaTicks per quarter note for each instance of PianoRoll.)\r<br />\nAlso, some extra things I've implemented for this Piano Roll is the ability to move notes with the mouse,<br />\na snap-to feature (1/2, 1/4, 1/8, 1/16 note or measure), from a selected from a ComboBox.  Or no snap to), zooming and a numbered grid.\r<br />\nThere are three layers of Canvases, the &quot;Holder Canvas&quot;, the size of which is used to determine whether or not the scrollbars should be visible.\r<br />\nAlso, a &quot;GridCanvas&quot; and &quot;NoteCanvas&quot; on top of this.  This setup was necessary for zooming, which is easy to do in WPF but not without caveats. \r<br />\nThe problem with just applying a ScaleTransform to the control is that things appear ugly as you increase the scale.  I think WPF just takes a visual snapshot of the control and renders a larger image of it, which means lines get thicker, etc..  It just doesn't look nice.  So you have to reset the StrokeThickness of lines within your layers to the inverse (1/ScaleTransform).  This is all done in the code behind which is posted below.<br />\n",
    "PostedDate": "2016-12-14T00:14:29.897-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489812",
    "ThreadId": "659904",
    "Html": "Below I'll also post the keyboard image I used as the background image for PianoDockPanel.\r<br />\nYou could make your own image, or use the one I use.  It's one long bitmap with all 128 keys shown.\r<br />\n<br />\nAlso in the above code, it might be wondered why I had to implement an extra horizontal scrollbar and disabled the one in the scrollviewer.  It's because of the asymmetrical way the scrolling has to be done.\r<br />\nThat is, horizontal scrolling of the note grid has to also scroll the top grid (which shows the beat numbers), but not the PianoDockPanel.  Conversely, vertical scrolling of the note grid has to vertical scroll the PianoDockPanel, but not the top grid.  So, I chose to put one of the scroll bars outside of the scrollviewer to make it simpler.<br />\n",
    "PostedDate": "2016-12-14T00:23:59.217-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489813",
    "ThreadId": "659904",
    "Html": "Here is the code behind (Part I):<br />\n<pre><code>using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Diagnostics;\nusing NAudio.Midi;\n\npublic class PianoRoll : UserControl\n\n{\n    private double xScale = 1.0 / 10;\n    private double yScale = 10;\n    private LinearGradientBrush NoteBrush = new LinearGradientBrush();\n\n    private LinearGradientBrush SelectedNoteBrush = new LinearGradientBrush();\n\n    public PianoRoll()\n    {\n        // This call is required by the designer.\n        InitializeComponent();\n\n        if (System.ComponentModel.DesignerProperties.GetIsInDesignMode(this)) {\n            return;\n        }\n\n        DrawHorizontalLines();\n\n        Canvas.SetZIndex(GridCanvas, 2);\n        //Bring grid canvas above holder canvas\n        Canvas.SetZIndex(NoteCanvas, 3);\n        //Bring note canvas to top\n\n        //Define brushes (could be moved to Xaml designer)\n        NoteBrush.StartPoint = new Point(0, 0);\n        NoteBrush.EndPoint = new Point(0, 1);\n        NoteBrush.GradientStops.Add(new GradientStop(Colors.White, 0));\n        NoteBrush.GradientStops.Add(new GradientStop(Colors.CadetBlue, 1));\n        SelectedNoteBrush.StartPoint = new Point(0, 0);\n        SelectedNoteBrush.EndPoint = new Point(0, 1);\n        SelectedNoteBrush.GradientStops.Add(new GradientStop(Colors.White, 0));\n        SelectedNoteBrush.GradientStops.Add(new GradientStop(Colors.Red, 1));\n\n\n    }\n\n    private void DrawHorizontalLines()\n    {\n        int GridHeight = yScale * 128;\n\n        for (int noteno = 0; noteno &lt;= 127; noteno++) {\n            switch (true) {\n\n                case noteno % 12 == 1:\n                case noteno % 12 == 3:\n                case noteno % 12 == 6:\n                case noteno % 12 == 8:\n                case noteno % 12 == 10:\n                    //C#, Eb, F#, Ab, Bb\n                    //Black key lines\n                    Rectangle blackkeyrect = new Rectangle();\n                    blackkeyrect.Fill = new SolidColorBrush(Color.FromArgb(100, 180, 180, 180));\n                    blackkeyrect.SetValue(Canvas.TopProperty, (GridHeight - yScale) - (noteno * yScale));\n                    blackkeyrect.Stroke = Brushes.Black;\n                    blackkeyrect.Margin = new Thickness(-1, 0, 0, 0);\n                    BindingOperations.SetBinding(blackkeyrect, Rectangle.WidthProperty, new Binding {\n                        Source = HolderCanvas,\n                        Path = new PropertyPath(&quot;ActualWidth&quot;)\n                    });\n                    blackkeyrect.Height = yScale;\n                    HolderCanvas.Children.Add(blackkeyrect);\n\n                    break;\n                default:\n                    //White key lines\n                    Line newline = new Line();\n                    newline.Stroke = Brushes.Black;\n                    newline.StrokeThickness = 1;\n                    newline.X1 = 0;\n                    BindingOperations.SetBinding(newline, Line.X2Property, new Binding {\n                        Source = HolderCanvas,\n                        Path = new PropertyPath(&quot;ActualWidth&quot;)\n                    });\n                    newline.Y1 = 0;\n                    newline.Y2 = 0;\n                    newline.SetValue(Canvas.TopProperty, (GridHeight - yScale) - (noteno * yScale));\n                    HolderCanvas.Children.Add(newline);\n\n                    break;\n            }\n            GridCanvas.Height = GridHeight;\n\n        }\n\n\n    }\n    private SolidColorBrush measureSeparatorBrush = new SolidColorBrush(Colors.Black);\n    private SolidColorBrush beatSeparatorBrush = new SolidColorBrush(Colors.LightGray);\n    private int lastPosition;\n\n    private int GridDisplayWidth;\n\n    private void DrawVerticalGrid()\n    {\n        GridCanvas.Children.Clear();\n        int beat = 0;\n        long n = 0;\n        while (n &lt;= GridDisplayWidth) {\n            Line line = new Line();\n            Line line2 = new Line();\n            TextBlock nTB = new TextBlock();\n            line.X1 = n * xScale;\n            line.X2 = line.X1;\n            line.Y1 = 0;\n            line.Y2 = 128 * yScale;\n            line2.X1 = n * xScale;\n            line2.X2 = line2.X1;\n            line2.Y1 = 0;\n            line2.Y2 = ScaleCanvas.ActualHeight;\n            if (beat % 4 == 0) {\n                line.Stroke = measureSeparatorBrush;\n                line2.Stroke = measureSeparatorBrush;\n                nTB.Margin = new Thickness(line2.X1, 0, 0, 0);\n                nTB.Text = (Conversion.Int(Conversion.Int(n / DeltaTicks) / 4) + 1).ToString;\n            } else {\n                line.Stroke = beatSeparatorBrush;\n                line2.Stroke = beatSeparatorBrush;\n            }\n            GridCanvas.Children.Add(line);\n            ScaleCanvas.Children.Add(line2);\n            ScaleCanvas.Children.Add(nTB);\n            beat += 1;\n            n += DeltaTicks;\n        }\n\n\n    }\n\n\n    private void DrawNotes()\n    {\n        NoteCanvas.Children.Clear();\n\n        foreach (MidiEvent midiEvent in MidiEvents) {\n            if (midiEvent.CommandCode == MidiCommandCode.NoteOn) {\n                NoteOnEvent NoteOn = (NoteOnEvent)midiEvent;\n                if (NoteOn.OffEvent != null) {\n                    Path rectpath = GetNoteRectPath(NoteOn.NoteNumber, NoteOn.AbsoluteTime, NoteOn.NoteLength, ref NoteOn);\n                    NoteHighPt = Math.Max(NoteHighPt, NoteOn.NoteNumber);\n                    NoteLowPt = Math.Min(NoteLowPt, NoteOn.NoteNumber);\n                    rectpath.MouseDown += MouseDownInNote;\n                    rectpath.MouseUp += MouseUpInNote;\n                    rectpath.MouseEnter += MouseEnterNote;\n                    rectpath.MouseLeave += MouseLeaveNote;\n                    rectpath.MouseMove += MouseMoveNote;\n                    NoteCanvas.Children.Add(rectpath);\n                }\n            }\n        }\n\n\n    }\n\n    private Path GetNoteRectPath(int noteNumber, long startTime, int duration, ref NoteOnEvent CustNoteOnEv)\n    {\n\n        Path rpath = new Path();\n        RectangleGeometry rectgeom = new RectangleGeometry();\n\n        rectgeom.Rect = new Rect(Convert.ToDouble(CustNoteOnEv.AbsoluteTime) * xScale, Convert.ToDouble(127 - CustNoteOnEv.NoteNumber) * yScale + 1, Convert.ToDouble(CustNoteOnEv.NoteLength) * xScale, (yScale - 1));\n\n        rectgeom.RadiusX = 1;\n        rectgeom.RadiusY = 1;\n        rpath.Stroke = RectBorderBrush;\n        rpath.StrokeThickness = 1;\n        rpath.Margin = new Thickness(0, 0, 0, 0);\n        rpath.Fill = NoteBrush;\n        rpath.Data = rectgeom;\n\n        return rpath;\n\n    }\n\n    SolidColorBrush RectBorderBrush = new SolidColorBrush(Colors.DarkBlue);\n    public int NoteHighPt = 0;\n    public int NoteLowPt = 127;\n    int InitialWidth;\n    public DependencyProperty MidiEventsDP { get; set; }\n    public DependencyProperty DeltaTicksDP { get; set; }\n\n    public void UpdatePianoRoll()\n    {\n        //Get Last position (for grid width)\n        lastPosition = 0;\n        foreach (MidiEvent midiEvent in MidiEvents) {\n            if (midiEvent.CommandCode == MidiCommandCode.NoteOn) {\n                NoteOnEvent noteOn = (NoteOnEvent)midiEvent;\n                if (noteOn.OffEvent != null) {\n                    lastPosition = Math.Max(lastPosition, noteOn.AbsoluteTime + noteOn.NoteLength);\n                }\n            }\n        }\n\n        // a quarter note is 20 units wide\n        xScale = (20.0 / DeltaTicks);\n\n        //Add an extra measure at right as visual buffer\n        GridDisplayWidth = (lastPosition + (DeltaTicks * 4) - (lastPosition % (DeltaTicks * 4))) + (4 * DeltaTicks);\n        InitialWidth = GridDisplayWidth * xScale;\n\n        NoteCanvas.Width = InitialWidth;\n\n        DrawVerticalGrid();\n\n        DrawNotes();\n\n        HolderCanvas.Width = Math.Max(InitialWidth, RLScrollViewer.ActualWidth);\n        GridCanvas.Width = HolderCanvas.ActualWidth;\n        ScaleCanvas.Width = HolderCanvas.ActualWidth;\n        MeasBufAdornerLayer.Width = HolderCanvas.ActualWidth;\n\n        //Linear gradient brush settings for non-editable area\n        MeasBuf1.Offset = ((NoteCanvas.ActualWidth - (4 * 20)) / HolderCanvas.ActualWidth);\n        MeasBuf2.Offset = MeasBuf1.Offset;\n\n        ScaleFactorX = RLScrollViewer.ActualWidth / InitialWidth;\n        ScalePianoRoll();\n\n        UDScrollViewer.ScrollToVerticalOffset(((NoteLowPt + NoteHighPt) / 2) * yScale - UDScrollViewer.ActualHeight / 2);\n        //Scroll to midrange area\n        RLScrollViewer.ScrollToHorizontalOffset(0);\n\n    }\n    public int DeltaTicks {\n        get { return GetValue(DeltaTicksDP); }\n        set { SetValue(DeltaTicksDP, value); }\n    }\n    public List&lt;MidiEvent&gt; MidiEvents {\n        get { return GetValue(MidiEventsDP); }\n        set {\n            SetValue(MidiEventsDP, value);\n            UpdatePianoRoll();\n        }\n    }\n\n\n    private void RLScrollBar_ValueChanged(object sender, RoutedPropertyChangedEventArgs&lt;double&gt; e)\n    {\n        int scrollval = e.NewValue * ((InitialWidth * ScaleFactorX) - RLScrollViewer.ActualWidth);\n        RLScrollViewer.ScrollToHorizontalOffset(scrollval);\n        ScaleScrollViewer.ScrollToHorizontalOffset(scrollval);\n\n    }\n    private void NoteCanvas_SizeChanged(object sender, SizeChangedEventArgs e)\n    {\n        UpdateHorizontalScrollBar();\n    }\n    private void UpdateHorizontalScrollBar()\n    {\n        RLScrollViewer.UpdateLayout();\n        if (HolderCanvas.ActualWidth == 0)\n            return;\n\n        decimal p = (RLScrollViewer.ActualWidth) / (InitialWidth * ScaleFactorX);\n        if (p &gt;= 1) {\n            ScrollBarDB.Visibility = Windows.Visibility.Collapsed;\n        } else {\n            ScrollBarDB.Visibility = Windows.Visibility.Visible;\n            RLScrollBar.ViewportSize = (RLScrollBar.Maximum - RLScrollBar.Minimum) * p / (1 - p);\n        }\n        RLScrollBar.Value += 0.01;\n        RLScrollBar.Value -= 0.01;\n        //trigger\n\n    }\n    private double ScaleFactorX = 1;\n\n    private void ScalePianoRoll()\n    {\n        HolderCanvas.LayoutTransform = new ScaleTransform(ScaleFactorX, 1);\n        //includes GridCanvas &amp; NoteCanvas\n        ScaleCanvas.LayoutTransform = new ScaleTransform(ScaleFactorX, 1);\n        NoteCanvas.LayoutTransform = new ScaleTransform(1 / ScaleFactorX, 1);\n        //Don't scale up the note canvas - only geometries in it\n\n        //Adjust grid line thicknesses\n        foreach (UIElement uielm in GridCanvas.Children) {\n            if (uielm.GetType() == typeof(Line)) {\n                ((Line)uielm).StrokeThickness = 1 / ScaleFactorX;\n            } else {\n                uielm.RenderTransform = new ScaleTransform(1 / ScaleFactorX, 1);\n            }\n        }\n        //Adjust note sizes\n        foreach (UIElement uielm in NoteCanvas.Children) {\n            if (uielm.GetType() == typeof(Path)) {\n                Path rpath = (Path)uielm;\n                rpath.Data.Transform = new ScaleTransform(ScaleFactorX, 1);\n            }\n        }\n        //Adjust scale line thicknesses\n        foreach (UIElement uielm in ScaleCanvas.Children) {\n            if (uielm.GetType() == typeof(Line)) {\n                ((Line)uielm).StrokeThickness = 1 / ScaleFactorX;\n            } else {\n                uielm.RenderTransform = new ScaleTransform(1 / ScaleFactorX, 1);\n            }\n        }\n\n        MeasBuf1.Offset = ((NoteCanvas.ActualWidth - (4 * 20)) / HolderCanvas.ActualWidth);\n        MeasBuf2.Offset = MeasBuf1.Offset;\n\n        //Add extra measures to fill space at right if smaller than the control\n        if (GridDisplayWidth * xScale &lt; RLScrollViewer.ActualWidth / ScaleFactorX) {\n            GridCanvas.Width = (RLScrollViewer.ActualWidth / ScaleFactorX);\n            GridDisplayWidth = (RLScrollViewer.ActualWidth / ScaleFactorX) / xScale;\n            DrawVerticalGrid();\n        }\n\n        UpdateHorizontalScrollBar();\n\n    }\n\n\n</code></pre>\n\n",
    "PostedDate": "2016-12-14T00:25:07.53-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489815",
    "ThreadId": "659904",
    "Html": "Code behind part 2: <br />\n<pre><code>private void HolderCanvas_MouseWheel(object sender, MouseWheelEventArgs e)\n    {\n        int NoMeasures = (GridDisplayWidth / DeltaTicks) / 4;\n        ScaleFactorX = Math.Min(Math.Max(ScaleFactorX + (e.Delta / 2000), 1), NoMeasures / 2);\n\n        ScalePianoRoll();\n\n    }\n    Path SelectedNotePath;\n    NoteOnEvent SelectedNote;\n    double CursorY;\n    double CursorX;\n    bool MouseDownOnNote;\n    RectangleGeometry SelRectGeom;\n    double SelRectTop;\n    double SelRectLeft;\n    public event NotesChangedEventHandler NotesChanged;\n    public delegate void NotesChangedEventHandler();\n    private void MouseUpInNote(object sender, MouseButtonEventArgs e)\n    {\n        MouseDownOnNote = false;\n        SelectedNotePath.ReleaseMouseCapture();\n        if (NotesChanged != null) {\n            NotesChanged();\n        }\n    }\n    private bool GetNoteFromGeom(MidiEvent midev)\n    {\n\n        bool IsNote = false;\n        if (midev.GetType == typeof(NoteOnEvent)) {\n            NoteOnEvent midnoteonev = (NoteOnEvent)midev;\n            IsNote = (SelRectGeom.Rect.Left == (midnoteonev.AbsoluteTime * xScale)) &amp; (SelRectGeom.Rect.Top == ((127 - midnoteonev.NoteNumber) * yScale + 1));\n            //IsNote = IsNote And SelRectGeom.Rect.Width = midnoteonev.NoteLength * xScale     'not necessary - enough to just get the x and y locations\n        }\n\n        return IsNote;\n\n    }\n\n    private void MouseDownInNote(object sender, MouseButtonEventArgs e)\n    {\n        MouseDownOnNote = true;\n        CursorY = e.GetPosition(sender).Y;\n        CursorX = e.GetPosition(sender).X;\n\n        SelectedNotePath = (Path)sender;\n        SelRectGeom = SelectedNotePath.Data;\n        SelRectTop = SelRectGeom.Rect.Y;\n        SelRectLeft = SelRectGeom.Rect.X;\n        SelectedNote = MidiEvents.Find(GetNoteFromGeom);\n\n        SelectedNotePath.CaptureMouse();\n\n        Canvas.SetZIndex(SelectedNotePath, NoteCanvas.Children.Count);\n        //show this note above all other notes\n\n    }\n\n    private void MouseMoveNote(object sender, MouseEventArgs e)\n    {\n        if (MouseDownOnNote) {\n            //Snap mouse y position to nearest note and limit to between 0-127\n            SelectedNote.NoteNumber = Math.Min(Math.Max(127 - Conversion.Int((SelRectTop + e.GetPosition(sender).Y - CursorY) / yScale), 0), 127);\n\n            int NewPos = SelRectLeft / xScale + (e.GetPosition(sender).X - CursorX) / (xScale * ScaleFactorX);\n            //Get the nearest snap position and limit to within max/min range\n            int SnapPosition = Math.Min(Math.Max(0, (NewPos - Conversion.Int(NewPos % NoteSnapTo))), lastPosition - Conversion.Int(lastPosition % NoteSnapTo));\n\n            int prevselnotetime = SelectedNote.AbsoluteTime;\n            SelectedNote.AbsoluteTime = SnapPosition;\n            SelectedNote.OffEvent.AbsoluteTime += (SelectedNote.AbsoluteTime - prevselnotetime);\n\n            SelRectGeom.Rect = new Rect(Convert.ToDouble(SelectedNote.AbsoluteTime) * xScale, Convert.ToDouble(127 - SelectedNote.NoteNumber) * yScale + 1, Convert.ToDouble(SelectedNote.NoteLength) * xScale, (yScale - 1));\n\n        }\n\n        //Scroll with mouse drag\n        if (e.GetPosition(UDScrollViewer).Y &lt; 0) {\n            UDScrollViewer.ScrollToVerticalOffset(UDScrollViewer.VerticalOffset - 0.1);\n        }\n        if (e.GetPosition(UDScrollViewer).Y &gt; UDScrollViewer.ActualHeight) {\n            UDScrollViewer.ScrollToVerticalOffset(UDScrollViewer.VerticalOffset + 0.1);\n        }\n        if (e.GetPosition(RLScrollViewer).X &lt; 0) {\n            RLScrollBar.Value -= 0.001;\n        }\n        if (e.GetPosition(RLScrollViewer).X &gt; RLScrollViewer.ActualWidth) {\n            RLScrollBar.Value += 0.001;\n        }\n\n    }\n    private void MouseEnterNote(object sender, MouseEventArgs e)\n    {\n        dynamic thisNotePath = (Path)sender;\n        thisNotePath.Fill = SelectedNoteBrush;\n    }\n\n    private void MouseLeaveNote(object sender, MouseEventArgs e)\n    {\n        dynamic thisNotePath = (Path)sender;\n        thisNotePath.Fill = NoteBrush;\n    }\n    int NoteSnapTo = 1;\n\n    private void SnapToCB_SelectionChanged(object sender, SelectionChangedEventArgs e)\n    {\n        switch (SnapToCB.SelectedValue.ToString) {\n            case &quot;Snap&quot;:\n                NoteSnapTo = 1;\n                break;\n            case &quot;1/2 note&quot;:\n                NoteSnapTo = DeltaTicks * 2;\n                break;\n            case &quot;1/4 note&quot;:\n                NoteSnapTo = DeltaTicks;\n                break;\n            case &quot;1/8 note&quot;:\n                NoteSnapTo = DeltaTicks / 2;\n                break;\n            case &quot;1/16 note&quot;:\n                NoteSnapTo = DeltaTicks / 4;\n                break;\n        }\n\n    }\n\n\n}\n</code></pre>\n\n",
    "PostedDate": "2016-12-14T00:26:46.167-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489817",
    "ThreadId": "659904",
    "Html": "Here is the piano bitmap I use:<br />\n<br />\n<img src=\"https://s28.postimg.org/5kbttqy8d/Piano_Long.jpg\" alt=\"Image\" /><br />\n",
    "PostedDate": "2016-12-14T00:39:49.147-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1489818",
    "ThreadId": "659904",
    "Html": "Incidentally, the MidiEventsDP and DeltaTicksDP are set as dependency properties to allow binding to other controls depending on how the PianoRoll will be implemented.  If it's not to have binding with anything, the dependency properties could be changed to simple Properties.<br />\n",
    "PostedDate": "2016-12-14T00:50:27.14-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]