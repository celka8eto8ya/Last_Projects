[
  {
    "Id": "275479",
    "ThreadId": "80369",
    "Html": "<p>I'm really struggling to wrap my head around NAudio.&nbsp; I have a series of filter graphs with a SampleBuffer with a callback that receives audio buffers as byte[] arrays filled with PCM encoded samples.&nbsp; I want to mix the audio from all the currently running graphs together using WaveMixerStream32 and then output the audio via ASIO.&nbsp;&nbsp; I understand what WaveMixerStream32 requires a WaveOffsetStream stream so data is always present.&nbsp;</p>\r\n<p>Is there anything built into NAudio that just lets me continuously pass the latest byte[] sample buffers from directshow into some type of WaveStream that I can wrap in a WaveOffsetStream?</p>\r\n<p>- Michael Tanczos</p>",
    "PostedDate": "2010-01-10T18:53:32.197-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "275570",
    "ThreadId": "80369",
    "Html": "<p>Hi Michael,</p>\r\n<p>I'm afraid there is nothing built-in yet, although this is a feature I really should get round to adding soon. What is needed is to store the received data temporarily (in some kind of buffer), and return whatever is available in the read method.</p>\r\n<p>Mark</p>",
    "PostedDate": "2010-01-11T02:01:35.973-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "275752",
    "ThreadId": "80369",
    "Html": "<p>So my line of thought is this then and you can tell me if this is correct. &nbsp; I'll write something up and post it and we can tear it apart then.</p>\r\n<p>Create a class that inherits WaveStream:</p>\r\n<ul>\r\n<li>WaveForm should match the bitrate of the stream, # channels, etc.</li>\r\n<li>CanRead should be true, CanSeek false, CanWrite false (?)</li>\r\n<li>Flush (no idea what this is for)</li>\r\n<li>Create an AddSample(byte[] buffer, int count) method  \r\n<ul>\r\n<li>Create a small queue of byte buffers that can be added to for storing incoming sample data. &nbsp;The queue would include objects that contain a byte[] buffer and a readposition integer</li>\r\n</ul>\r\n</li>\r\n<li>Length - Return long.MaxValue</li>\r\n<li>Position - Return current read position (make sure it is evenly divisible by BlockAlign)</li>\r\n<li>The Read(byte[] buffer, int offset, int count)&nbsp;method should then:  \r\n<ul>\r\n<li>Peek at first item in queue and read count bytes from it. &nbsp;Before the buffer can be removed from the queue you would have to ensure that the whole thing was read</li>\r\n<li>If insufficient sample data exists, generate silence</li>\r\n<li>Update Position by number of bytes read</li>\r\n</ul>\r\n</li>\r\n<li>Override hasData to always return true</li>\r\n<li>Anything else?</li>\r\n</ul>\r\n<p>- Michael Tanczos</p>",
    "PostedDate": "2010-01-11T09:06:47.947-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "275969",
    "ThreadId": "80369",
    "Html": "<p>I wrote up what I stated as follows, but the audio is playing a bit slower than it should and is falling further and further behind the video each second. &nbsp;The BufferedSampleStream was created as a 48Khz stream to match the input stream. &nbsp;ugh.. &nbsp;The mixer should technically just about play the queued samples as they are queued I would think, but over time I'm getting a larger and larger buffer queue of samples. &nbsp;EDIT: Okay, I see that the mixer has a hard coded rate in the constructor of 44.1Khz</p>\r\n<p>I'm setting up the mixer as follows:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>        _audioStream = <span style=\"color:Blue\">new</span> BufferedSampleStream();\r\n        channelSteam[0] = <span style=\"color:Blue\">new</span> WaveChannel32(_audioStream);\r\n        channelSteam[0].Position = 0;\r\n\r\n        mixer.AddInputStream(channelSteam[0]);\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>// BufferedSampleStream code (this does in fact work)</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> SampleBlock\r\n    {\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">byte</span>[] _buffer;\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">int</span> _position;\r\n\r\n        <span style=\"color:Blue\">public</span> SampleBlock(<span style=\"color:Blue\">byte</span>[] buffer)\r\n        {\r\n            _position = 0;\r\n            _buffer = buffer;\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">byte</span>[] Buffer\r\n        {\r\n            <span style=\"color:Blue\">get</span>\r\n            {\r\n                <span style=\"color:Blue\">return</span> _buffer;\r\n            }\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">int</span> Position\r\n        {\r\n            <span style=\"color:Blue\">get</span>\r\n            {\r\n                <span style=\"color:Blue\">return</span> _position;\r\n            }\r\n            <span style=\"color:Blue\">set</span>\r\n            {\r\n                _position = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> BufferedSampleStream : WaveStream\r\n    {\r\n        <span style=\"color:Blue\">private</span> WaveFormat _waveformat;\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">long</span> _position;\r\n        <span style=\"color:Blue\">private</span> Queue _sampQueue;\r\n\r\n        <span style=\"color:Blue\">public</span> BufferedSampleStream()\r\n        {\r\n            _waveformat = <span style=\"color:Blue\">new</span> WaveFormat(44100, 2);\r\n            _position = 0;\r\n            _sampQueue = <span style=\"color:Blue\">new</span> Queue();\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> BufferedSampleStream(<span style=\"color:Blue\">int</span> rate, <span style=\"color:Blue\">int</span> channels)\r\n        {\r\n            _waveformat = <span style=\"color:Blue\">new</span> WaveFormat(rate, channels);\r\n            _position = 0;\r\n            _sampQueue = <span style=\"color:Blue\">new</span> Queue();\r\n        }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> Adds a byte[] array of PCM encoded samples to be streamed</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">void</span> AddSamples(<span style=\"color:Blue\">byte</span>[] buffer, <span style=\"color:Blue\">int</span> offset, <span style=\"color:Blue\">int</span> count)\r\n        {\r\n            <span style=\"color:Blue\">byte</span>[] nbuffer = <span style=\"color:Blue\">new</span> <span style=\"color:Blue\">byte</span>[count];\r\n            Buffer.BlockCopy(buffer, offset, nbuffer, 0, count);\r\n\r\n            <span style=\"color:Blue\">lock</span> (_sampQueue)\r\n            {\r\n                _sampQueue.Enqueue(<span style=\"color:Blue\">new</span> SampleBlock(nbuffer));\r\n            }\r\n        }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> We can read from this stream</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">bool</span> CanRead { <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>; } }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> We can seek within this stream</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">bool</span> CanSeek { <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>; } }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> We can't write to this stream</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">bool</span> CanWrite { <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>; } }\r\n        \r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> WaveFormat WaveFormat\r\n        {\r\n            <span style=\"color:Blue\">get</span>\r\n            {\r\n                <span style=\"color:Blue\">return</span> _waveformat;\r\n            }\r\n        }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> An alternative way of repositioning.</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> See &lt;see cref=&quot;Stream.Seek&quot;/&gt;</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">long</span> Seek(<span style=\"color:Blue\">long</span> offset, SeekOrigin origin)\r\n        {\r\n            <span style=\"color:Blue\">return</span> Position;\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">long</span> Length\r\n        {\r\n            <span style=\"color:Blue\">get</span> { <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">long</span>.MaxValue / 32; }\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">long</span> Position\r\n        {\r\n            <span style=\"color:Blue\">get</span>\r\n            {\r\n                <span style=\"color:Blue\">return</span> _position;\r\n            }\r\n            <span style=\"color:Blue\">set</span>\r\n            {\r\n                _position = value;\r\n            }\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">bool</span> HasData(<span style=\"color:Blue\">int</span> count)\r\n        {\r\n            <span style=\"color:Green\">// This buffered sample stream will always return some type of audio data</span>\r\n            <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>;\r\n        }\r\n\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:Gray\">///</span><span style=\"color:Green\"> Reads sample data from queued samples, if queue is empty generates silence</span>\r\n        <span style=\"color:Gray\">///</span> <span style=\"color:Gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">int</span> Read(<span style=\"color:Blue\">byte</span>[] buffer, <span style=\"color:Blue\">int</span> offset, <span style=\"color:Blue\">int</span> count)\r\n        {\r\n            <span style=\"color:Blue\">int</span> read = 0;\r\n            <span style=\"color:Blue\">while</span> (read &lt; count)\r\n            {\r\n                <span style=\"color:Blue\">int</span> required = count - read;\r\n                <span style=\"color:Blue\">if</span> (_sampQueue.Count == 0)\r\n                {\r\n                    <span style=\"color:Green\">// Return a zero filled buffer</span>\r\n                    <span style=\"color:Blue\">for</span> (<span style=\"color:Blue\">int</span> n = 0; n &lt; required; n++)\r\n                        buffer[offset + n] = 0;\r\n\r\n                    read += required;\r\n                }\r\n                <span style=\"color:Blue\">else</span>\r\n                {\r\n                    SampleBlock sblock = (SampleBlock)_sampQueue.Peek();\r\n\r\n                    <span style=\"color:Blue\">int</span> nread = sblock.Buffer.Length - sblock.Position;\r\n\r\n                    <span style=\"color:Green\">// If this buffer must be read in it's entirety</span>\r\n                    <span style=\"color:Blue\">if</span> (nread &lt;= required)\r\n                    {\r\n                        <span style=\"color:Green\">// Read entire buffer</span>\r\n                        Buffer.BlockCopy(sblock.Buffer, sblock.Position, buffer, offset + read, nread);\r\n                        read += nread;\r\n\r\n                        _sampQueue.Dequeue();\r\n\r\n                    }\r\n                    <span style=\"color:Blue\">else</span> <span style=\"color:Green\">// the number of bytes that can be read is greater than that required</span>\r\n                    {\r\n                        Buffer.BlockCopy(sblock.Buffer, sblock.Position, buffer, offset + read, required);\r\n                        sblock.Position += required;\r\n                        read += required;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            _position += read;\r\n\r\n            <span style=\"color:Blue\">return</span> read;\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-11T19:00:19.06-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "275985",
    "ThreadId": "80369",
    "Html": "<p>Something like this would present a secondary problem.. is there a way to dynamically resample audio from 48Khz to 44.1Khz (something makes me think this part isn't going to be easy). &nbsp;I can't be assured that all input streams will be the same bitrate.&nbsp;</p>\r\n<p>EDIT 1/13:&nbsp;</p>\r\n<p>To assure that all streams are a uniform bitrate coming out of directshow i'm going to use the ACM Wrapper from Microsoft.. downsampling isn't so great but upsampling everything to 48Khz seems to sound pretty good. &nbsp;Then I'll just lock the mixer to 48Khz instead of 44.1Khz and no more beating my head against a keyboard to figure out a good way to do this. &nbsp;I'll have the audio in a format I want to begin with. &nbsp;As for the resampler, it probably would have just been a lowpass filter with a frequency cutoff of 22.05Khz and then remove every nth sample.</p>\r\n<p>- Michael Tanczos</p>",
    "PostedDate": "2010-01-11T20:18:33.343-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "431526",
    "ThreadId": "80369",
    "Html": "<p>you could try the ResamplerDmoStream if the ACM wrapper isn't to your liking.</p>\r\n<p>Mark</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-04-15T09:03:35.237-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "431659",
    "ThreadId": "80369",
    "Html": "<p>Hi</p>\r\n<p>&nbsp;</p>\r\n<p>I am new here. I wonder if there is any possibility to get an class where I can mix audio streams together. Have you any solution?</p>",
    "PostedDate": "2010-04-15T14:40:04.053-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "431915",
    "ThreadId": "80369",
    "Html": "<p>hi goldengel,</p>\r\n<p>try the WaveMixer32Stream class</p>\r\n<p>Mark</p>",
    "PostedDate": "2010-04-16T06:23:36.317-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "497833",
    "ThreadId": "80369",
    "Html": "<p>Hi,</p>\r\n<p>I'm trying to get audio streaming over a network using NAudio and stumbled across this but can't seem to get it working. I need to stream different file types so the server side will need to send the stream data as PCM so regardless of the file format it arrives at the client the same.</p>\r\n<p>I have created the class above but can't seem to get it going.</p>\r\n<p>&nbsp;from the server end (mp3):</p>\r\n<pre style=\"font-family:consolas\">NAudio.Wave.<span style=\"color:#2b91af\">Mp3FileReader </span>readerStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">Mp3FileReader</span>(fileName);<br>NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;pcmStream&nbsp;=&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveFormatConversionStream</span>.CreatePcmStream(readerStream);<br>NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;blockAlignedStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">BlockAlignReductionStream</span>(pcmStream);<br>NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;inputStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveChannel32</span>(blockAlignedStream);</pre>\r\n<pre style=\"font-family:consolas\">I then loop through inputStream&nbsp;and send the data over the network.<br></pre>\r\n<pre style=\"font-family:consolas\">from the client end I first init the sound device and create a BufferedSampleStream and point the waveOutDevice to that stream:</pre>\r\n<pre style=\"font-family:consolas\"><pre style=\"font-family:consolas\">waveOutDevice&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">DirectSoundOut</span>();<br><br>_audioStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">BufferedSampleStream</span>();<br>NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;inputStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveChannel32</span>(_audioStream);<br><br>waveOutDevice.Init(inputStream);<br>waveOutDevice.Play();</pre>\r\n<pre style=\"font-family:consolas\">Then when the network connection on the client receives data, I grab it from the NetworkStream and add it to the BufferedSampleStream:</pre>\r\n<pre style=\"font-family:consolas\"><pre style=\"font-family:consolas\">&nbsp;</pre>\r\n<pre style=\"font-family:consolas\">_audioStream.AddSamples(bytReceiveBuffer,&nbsp;0,&nbsp;(<span style=\"color:blue\">int</span>)bytReceiveBuffer.Length);<br></pre>\r\n<pre style=\"font-family:consolas\">&nbsp;</pre>\r\n<pre style=\"font-family:consolas\">&nbsp;</pre>\r\n<pre style=\"font-family:consolas\">No sound comes out. Where have  I gone wrong?</pre>\r\n</pre>\r\n</pre>",
    "PostedDate": "2010-09-23T17:01:01.047-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "497868",
    "ThreadId": "80369",
    "Html": "<p>OK,</p>\r\n<p>I can now get sound out (there was a problem with my loop for reading the data from the actual audio stream before sending over the network.)</p>\r\n<p>HOWEVER!!!</p>\r\n<p>Now all I get is scrambled noise. I'm guessing I still have a problem with my loop that reads the audio data from the file before sending it (over the network) to the play stream....</p>\r\n<p>Here is some code that essentially does the server/client thing without the actual network bit....</p>\r\n<p>The code below is producing weird noises - and not playing the actual file. It also ends up crashing with an out of memory exception. Playing the file directly works perfectly.</p>\r\n<p>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">IWavePlayer</span>&nbsp;waveOutDevice&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">DirectSoundOut</span>();<br><span style=\"color:blue\">private</span>&nbsp;<span style=\"color:blue\">void</span>&nbsp;button1_Click(<span style=\"color:blue\">object</span>&nbsp;sender,&nbsp;<span style=\"color:#2b91af\">EventArgs</span>&nbsp;e)&nbsp;{<br>&nbsp;&nbsp;&nbsp; System.Threading.<span style=\"color:#2b91af\">Thread</span>&nbsp;objThread&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;System.Threading.<span style=\"color:#2b91af\">Thread</span>(PlayFile);<br>&nbsp;&nbsp;&nbsp; objThread.Start();<br>}<br><br><span style=\"color:blue\">void</span>&nbsp;PlayFile()&nbsp;{<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;string</span>&nbsp;fileName&nbsp;=&nbsp;<span style=\"color:#a31515\">&quot;c:\\\\temp\\\\Music\\\\1.mp3&quot;</span>;<br><span style=\"color:#2b91af\">&nbsp;&nbsp;&nbsp;WaveStream</span>&nbsp;mp3Reader&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">Mp3FileReader</span>(fileName);<br><span style=\"color:#2b91af\">&nbsp;&nbsp;&nbsp;WaveStream</span>&nbsp;pcmStream&nbsp;=&nbsp;<span style=\"color:#2b91af\">WaveFormatConversionStream</span>.CreatePcmStream(mp3Reader);<br><span style=\"color:#2b91af\">&nbsp;&nbsp;&nbsp;WaveStream</span>&nbsp;blockAlignedStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">BlockAlignReductionStream</span>(pcmStream);<br>&nbsp;&nbsp;&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;audioStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">WaveChannel32</span>(blockAlignedStream);<br><br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;if</span>&nbsp;(<span style=\"color:blue\">true</span>&nbsp;==&nbsp;<span style=\"color:blue\">false</span>)&nbsp;{<br><span style=\"color:green\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Play&nbsp;file&nbsp;directly</span><br><span style=\"color:green\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//waveOutDevice.Init(audioStream);</span><br>&nbsp;&nbsp;&nbsp;}&nbsp;<span style=\"color:blue\">else</span>&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">BufferedSampleStream</span>&nbsp;bufferedStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:#2b91af\">BufferedSampleStream</span>();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveStream</span>&nbsp;inputStream&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;NAudio.Wave.<span style=\"color:#2b91af\">WaveChannel32</span>(bufferedStream);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waveOutDevice.Init(inputStream);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waveOutDevice.Play();<br><br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while</span>&nbsp;(<span style=\"color:blue\">true</span>)&nbsp;{<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span>&nbsp;intOffset&nbsp;=&nbsp;0;<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span>&nbsp;intSize&nbsp;=&nbsp;234523;<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte</span>[]&nbsp;buffer&nbsp;=&nbsp;<span style=\"color:blue\">new</span>&nbsp;<span style=\"color:blue\">byte</span>[intSize];<br><br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</span>&nbsp;intRead&nbsp;=&nbsp;audioStream.Read(buffer,&nbsp;intOffset,&nbsp;intSize);<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</span>&nbsp;(intRead&nbsp;==&nbsp;0)&nbsp;{<br><span style=\"color:blue\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span style=\"color:green\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//SERVER:&nbsp;Code&nbsp;Send&nbsp;data&nbsp;over&nbsp;network</span><br><br><br><span style=\"color:green\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CLIENT:&nbsp;Receive&nbsp;data&nbsp;from&nbsp;network&nbsp;and&nbsp;add&nbsp;to&nbsp;buffered&nbsp;stream</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bufferedStream.AddSamples(buffer,&nbsp;intOffset,&nbsp;intSize);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}<br>}</p>",
    "PostedDate": "2010-09-23T19:12:25.663-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "497900",
    "ThreadId": "80369",
    "Html": "<p>The last code I posted has some major problems within a few seconds, the executable runs out of memory. This is all happening here -&gt; bufferedStream.AddSamples(buffer,&nbsp;intOffset,&nbsp;intSize);<br><br>I am completely stuck now. Has anyone got network streaming working with NAudio?</p>",
    "PostedDate": "2010-09-23T22:32:23.007-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1011242",
    "ThreadId": "80369",
    "Html": "I know this is several years old now, but I am trying to do the same thing.\r<br />\nI have a new thread: <a href=\"http://naudio.codeplex.com/discussions/435595\" rel=\"nofollow\">http://naudio.codeplex.com/discussions/435595</a><br />\n",
    "PostedDate": "2013-03-06T07:53:25.21-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]