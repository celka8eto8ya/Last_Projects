[
  {
    "Id": "1074490",
    "ThreadId": "451802",
    "Html": "I was stuck with problem that I wanted to use coding and encoding in memory.  I resolved the issue with MediaFoundationReader, which read the file from physical path and doesn't support this operation using memory stream. And what to share my approach\r<br />\n<br />\nSo I've extended this class as following:<br />\n<pre><code>internal class ExtendedMediaFounadtionReader : MediaFoundationReader\n    {\n        private static byte[] fileContent;\n        private static string SetFileContentFromBytesArray(byte[] audioFile)\n        {\n            fileContent = audioFile;\n            return null;\n        }\n        public ExtendedMediaFounadtionReader(string file) : base(file)\n        {\n        }\n\n        public ExtendedMediaFounadtionReader(string file, MediaFoundationReaderSettings settings) : base(file, settings)\n        {\n        }\n\n        public ExtendedMediaFounadtionReader(byte[] file)\n            : base(SetFileContentFromBytesArray(file))\n        {\n        }\n\n        public ExtendedMediaFounadtionReader(byte[] file, MediaFoundationReaderSettings settings)\n            : base(SetFileContentFromBytesArray(file), settings)\n        {\n        }\n\n        protected override IMFSourceReader CreateReader(MediaFoundationReaderSettings settings)\n        {\n            if (fileContent == null)\n            {\n                return base.CreateReader(settings);\n            }\n            IMFSourceReader ppSourceReader;\n            IMFByteStream ppStream;\n            var memoryStream = new MemoryStream();\n            memoryStream.Write(fileContent, 0, fileContent.Length);\n            var stream = new ManagedIStream(memoryStream);\n            ExtendedMediaFoundationInterop.MFCreateMFByteStreamOnStream(stream, out ppStream);\n            MediaFoundationInterop.MFCreateSourceReaderFromByteStream(ppStream, null, out ppSourceReader);\n            ppSourceReader.SetStreamSelection(-2, false);\n            ppSourceReader.SetStreamSelection(-3, true);\n            ppSourceReader.SetCurrentMediaType(-3, IntPtr.Zero, new MediaType\n                {\n                    MajorType = MediaTypes.MFMediaType_Audio,\n                    SubType = (settings.RequestFloatOutput ? AudioSubtypes.MFAudioFormat_Float : AudioSubtypes.MFAudioFormat_PCM)\n                }.MediaFoundationObject);\n            return ppSourceReader;\n        }\n    }</code></pre>\n\nAs you can see this CreateReader file uses MFCreateMFByteStreamOnStream for creating of byte stream (this method wasn't wrapper in MediaFoundationInterop, instead of it there is MFCreateMFByteStreamOnStreamEx which exist only in Windows 8). To wrap this method I added another class:<br />\n<pre><code>    internal static class ExtendedMediaFoundationInterop\n    {\n        [DllImport(&quot;mfplat.dll&quot;, PreserveSig = false)]\n        public static extern void MFCreateMFByteStreamOnStream(IStream punkStream, out IMFByteStream ppByteStream);\n    }</code></pre>\n\nwith this function. And also I've implemented simple COM IStream interface:<br />\n<pre><code>    internal sealed class ManagedIStream : IStream\n    {\n        public ManagedIStream(Stream stream)\n        {\n            if (stream == null)\n                throw new ArgumentNullException(&quot;stream&quot;);\n\n            _stream = stream;\n        }\n\n        void IStream.Read(byte[] buffer, int cb, IntPtr pcbRead)\n        {\n            int val = _stream.Read(buffer, 0, cb);\n            if (pcbRead != IntPtr.Zero)\n                Marshal.WriteInt32(pcbRead, val);\n        }\n\n        void IStream.Write(byte[] buffer, int cb, IntPtr pcbWritten)\n        {\n            _stream.Write(buffer, 0, cb);\n            if (pcbWritten != IntPtr.Zero)\n                Marshal.WriteInt32(pcbWritten, cb);\n        }\n\n        void IStream.Seek(long offset, int dwOrigin, IntPtr plibNewPosition)\n        {\n            SeekOrigin origin;\n            switch (dwOrigin)\n            {\n                case 0: origin = SeekOrigin.Begin; break;\n                case 1: origin = SeekOrigin.Current; break;\n                case 2: origin = SeekOrigin.End; break;\n                default: throw new ArgumentOutOfRangeException(&quot;dwOrigin&quot;);\n            }\n\n            long val = _stream.Seek(offset, origin);\n            if (plibNewPosition != IntPtr.Zero)\n                Marshal.WriteInt64(plibNewPosition, val);\n        }\n\n        void IStream.SetSize(long libNewSize)\n        {\n            _stream.SetLength(libNewSize);\n        }\n\n        void IStream.Stat(out STATSTG pstatstg, int grfStatFlag)\n        {\n            pstatstg = new STATSTG\n            {\n                type = 2,\n                cbSize = _stream.Length,\n            };\n\n            if (_stream.CanRead &amp;&amp; _stream.CanWrite)\n                pstatstg.grfMode = 0x00000002;\n            else if (_stream.CanWrite)\n                pstatstg.grfMode = 0x00000001;\n            else if (_stream.CanRead)\n                pstatstg.grfMode = 0x00000000;\n            else\n                throw new IOException();\n        }\n\n        void IStream.Clone(out IStream ppstm)\n        {\n            ppstm = null;\n            throw new NotSupportedException();\n        }\n\n        readonly Stream _stream;\n    }</code></pre>\n\nThis works perfectly in Windows 7,\r<br />\n<strong>But I have an issue with extending of MediaFoundationEncoder:</strong>\r<br />\n<br />\nActually Windows Media Foundation supports in MFCreateSinkWriterFromURL creation of writer to the bytes stream, but all methods involved to encoding process are private and I'm not able to extend it properly, so I wanted to ask if such future will be planned in future releases? I really need it :)\r<br />\n<br />\nThanks, Roman Badiornyi.<br />\n",
    "PostedDate": "2013-07-29T15:16:03.43-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1083129",
    "ThreadId": "451802",
    "Html": "hi Roman, MediaFoundationEncoder is still a fairly new part of NAudio, and it would be nice to support encoding in memory. If you want to create your own patch to NAudio to support this I would definitely consider including it. My time to work on this has been rather limited recently. I may end up releasing NAudio 1.7 with it in its current state as a &quot;preview&quot; feature, and work a bit more in NAudio 1.8 on improving the API for Windows Store app situations.<br />\n",
    "PostedDate": "2013-08-21T07:44:48.637-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1201578",
    "ThreadId": "451802",
    "Html": "I have added this functionality to a fork in NAudio <br />\n<br />\nRather than use ExtendedMediaFounadtionReader I added the code directly into MediaFoundationReader.cs<br />\nMediaFoundationReader can now open streams.<br />\n<br />\n<a href=\"https://naudio.codeplex.com/SourceControl/network/forks/K24A3/MediaFoundationStreamSupport/contribution/6137\" rel=\"nofollow\">https://naudio.codeplex.com/SourceControl/network/forks/K24A3/MediaFoundationStreamSupport/contribution/6137</a><br />\n",
    "PostedDate": "2014-02-01T02:30:02.337-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]